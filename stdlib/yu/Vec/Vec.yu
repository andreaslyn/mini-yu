import "yu/Nat/Nat.yu"


data Vec : Nat & Ty -> Ty
let nil.Vec [A : Ty] : Vec 0 A
let _::_\Vec [A : Ty] [n : Nat] : A & Vec n A -> Vec (++ n) A


val _.head\Vec [A : Ty] [n : Nat] : Vec (++ n) A -> A
let (x :: _) => x


val _.tail\Vec [A : Ty] [n : Nat] : Vec (++ n) A -> Vec n A
let (_ :: xs) => xs


val _.accum\Vec [A : Ty] [B : Ty] [n : Nat] :
  Vec n B & A & (A & B -> A) -> A
let nil.Vec a _ => a
let (x :: xs) a f => xs .accum (f a x) f


val _.map\Vec [A B : Ty] [n : Nat] : Vec n A & (A -> B) -> Vec n B
let nil.Vec _ => nil.Vec
let (x :: xs) f => f x :: xs .map f


val _.index\Vec [A : Ty] [n : Nat] : Vec n A & (i : Nat) & ? (i <? n) -> A
let nil.Vec 0 {}
let nil.Vec (++ _) {}
let (x :: xs) 0 _ => x
let (_ :: xs) (++ i) L => xs .index i L
