import N => yu/Nat
| Nat
| 0
| (...#Nat)

import B => yu/basic/Bool
| Bool
| (...#Bool)


data Vec : Nat & Ty -> Ty
| nil [A : Ty] : Vec 0 A
| (::#Vec) [A : Ty] [n : Nat] : A & Vec n A -> Vec (++ n) A


val (.head#Vec) [A : Ty] [n : Nat] : Vec (++ n) A -> A
let (x :: _) => x


val (.tail#Vec) [A : Ty] [n : Nat] : Vec (++ n) A -> Vec n A
let (_ :: xs) => xs


val (.accum#Vec) [A : Ty] [B : Ty] [n : Nat] :
  Vec n B & A & (A & B -> A) -> A
let nil a _ => a
let (x :: xs) a f => xs .accum (f a x) f


val (.map#Vec) [A B : Ty] [n : Nat] : Vec n A & (A -> B) -> Vec n B
let nil _ => nil
let (x :: xs) f => f x :: xs .map f


val (.index#Vec) [A : Ty] [n : Nat] : Vec n A & (i : Nat) & ? (i <? n) -> A
let nil 0 {}
let nil (++ _) {}
let (x :: xs) 0 _ => x
let (_ :: xs) (++ i) L => xs .index i L
