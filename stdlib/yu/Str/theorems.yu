import Str => yu/Str/Str
| Str
| (...#Str)

import C => yu/Char/Char

import Eq => yu/basic/Equal
| (=#)

import List-th => yu/List/theorems

import Ord => yu/Order/Order
| Order
| (...#Order)

import B => yu/Bool/Bool
| Bool

import relation? => yu/relation?/relation?
| (...#Bool)

import Ord? => yu/Ordering?/Ordering?
| Ordering?
| (...#Ordering?)

import Ord?-th => yu/Ordering?/theorems
| (...#Ordering?)

import Equivalence? => yu/Equivalence?/Equivalence?
| Equivalence?
| (...#Equivalence?)


val cmpIsTransitive? : cmpToLe?.Ord? (.cmp#Str) .IsTransitive?
let r s t lrs lst =>
  cmpIsTransitive?.List-th
    ordering?.C (r .list) (s .list) (t .list) lrs lst


val cmpIsCompatible : (r s : Str) -> r .cmp s .lt? = s .cmp r .gt?
let r s => cmpIsCompatible.List-th ordering?.C (r .list) (s .list)


val ordering? : Ordering? Str
let => fromCmp.Ord? (.cmp#Str) cmpIsTransitive? cmpIsCompatible


val equivalence? : Equivalence? Str
let => ordering? .equivalence?
