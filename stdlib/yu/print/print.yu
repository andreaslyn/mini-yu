import basic => yu/basic
| Bool
| Nat
| List
| (::#List)

import C => yu/Char/Type
| Char

import S => yu/Str/Str
| Str
| (...#Str)

import SS => yu/Str/StrStr
| (.str#Bool)
| (.str#Nat)
| (.str#List)
| (.str#Char)


extern (.print#Char) : Char ->> {}

val (.println#Char) : Char ->> {}
let c => c .print; 'lf.C .print


val (.print#Str) : Str ->> {}
let str => aux (str .list)
where
  val aux : List Char ->> {}
  let nil.basic => ()
  let (c :: cs) => c .print; aux cs
end

val (.println#Str) : Str ->> {}
let s => s .print; 'lf.C .print


val (.print#Bool) : Bool ->> {}
let b => b .str .print

val (.println#Bool) : Bool ->> {}
let b => b .print; 'lf.C .print


val (.print#Nat) : Nat ->> {}
let n => n .str .print

val (.println#Nat) : Nat ->> {}
let n => n .print; 'lf.C .print


val (.print#List) [A : Ty] : List A & (A -> Str) & Str ->> {}
let xs f s => xs .str f s .print

val (.println#List) [A : Ty] : List A & (A -> Str) & Str ->> {}
let xs f s => xs .print f s; 'lf.C .print
