import "yu/basic/Equal.yu"
import "yu/Bool/Bool.yu"


data _IsNat\Ty : Ty -> Ty
let mk.IsNat[N : Ty] :
  (zero : N, succ : N -> N,
    ind : (n : N, P : N -> Ty, P(zero), (x : N, P(x)) -> P(succ(x))) -> P(n),
    (P : N -> Ty, p0 : P(zero), pi : (x : N, P(x)) -> P(succ(x))) ->
      ind(zero, P, p0, pi) = p0,
    (n : N, P : N -> Ty, p0 : P(zero), pi : (x : N, P(x)) -> P(succ(x))) ->
      ind(succ(n), P, p0, pi) = pi(n, ind(n, P, p0, pi))
  ) -> N IsNat


val _zero\_IsNat\Ty[N : Ty] : N IsNat -> N
let (mk.IsNat(zero, _, _, _, _)) => zero


val _succ\_IsNat\Ty[N : Ty] : N IsNat -> N -> N
let (mk.IsNat(_, succ, _, _, _)) => succ


val _ind\_IsNat\Ty[N : Ty] :
  (H : N IsNat) ->
  (n : N, P : N -> Ty, P(H zero), (x : N, P(x)) -> P(H succ(x))) -> P(n)
let (mk.IsNat(_, _, ind, _, _)) => ind


val _simplIndZero\_IsNat\Ty[N : Ty] :
  (H : N IsNat) ->
  (P : N -> Ty, p0 : P(H zero), pi : (x : N, P(x)) -> P(H succ(x))) ->
  H ind(H zero, P, p0, pi) = p0
let (mk.IsNat(_, _, _, succ, _)) => succ


val _simplIndSucc\_IsNat\Ty[N : Ty] :
  (H : N IsNat) ->
  (n : N, P : N -> Ty, p0 : P(H zero), pi : (x : N, P(x)) -> P(H succ(x))) ->
  H ind(H succ(n), P, p0, pi) = pi(n, H ind(n, P, p0, pi))
let (mk.IsNat(_, _, _, _, succ)) => succ


val _rec\_IsNat\Ty[N : Ty, A : Ty] :
  (H : N IsNat) -> (N, A, (N, A) -> A) -> A
let (H) => (n, a0, ai). H ind(n, const(A), a0, ai)


val _simplRecZero\_IsNat\Ty[N : Ty, A : Ty] :
  (H : N IsNat) ->
  (a0 : A, ai : (N, A) -> A) ->
  H rec(H zero, a0, ai) = a0
let (H) => (a0, ai). H simplIndZero(const(A), a0, ai)


val _simplRecSucc\_IsNat\Ty[N : Ty, A : Ty] :
  (H : N IsNat) ->
  (n : N, a0 : A, ai : (N, A) -> A) ->
  H rec(H succ(n), a0, ai) = ai(n, H rec(n, a0, ai))
let (H) => (n, a0, ai). H simplIndSucc(n, const(A), a0, ai)


val _pred\_IsNat\Ty[N : Ty] : N IsNat -> N -> N
let (H) => (n). H rec(n, H zero, (n', _). n')


val _simplPredZero\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> H pred(H zero) = H zero
let (H) => H simplRecZero(H zero, (n', _). n')


val _simplPredSucc\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (n : N) -> H pred(H succ(n)) = n
let (H) => (n). H simplRecSucc(n, H zero, (n', _). n')


val _injectiveSucc\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (m : N, n : N, H succ(m) = H succ(n)) -> m = n
let (H) => (m, n, e).
  ! H simplPredSucc(m) @ e ap(H pred) @ H simplPredSucc(n)


val _succ<>Zero\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (n : N) -> H succ(n) <> H zero
let (H) => (n). (e). case contra(n, e) of () end
where
  val contra : (n : N, H succ(n) = H zero) -> true = false
  let (n, e) =>
    ! H simplRecSucc(n, false, (_, _). true)
    @ e ap((x). H rec(x, false, (_, _). true))
    @ H simplRecZero(false, (_, _). true)
end


data _Leq\_IsNat\Ty[N : Ty] : N IsNat -> (N, N) -> Ty
let leqZero.IsNat[N : Ty, H : N IsNat, n : N] : H Leq(H zero, n)
let _leqSucc\_Leq\_IsNat\Ty[N : Ty, H : N IsNat, m : N, n : N] :
  H Leq(m, n) -> H Leq(H succ(m), H succ(n))


val _ind\_Leq\_IsNat\Ty[N : Ty, H : N IsNat, m : N, n : N] :
  (L : H Leq(m, n), P : (x : N, y : N, H Leq(x, y)) -> Ty,
    (y : N) -> P(H zero, y, leqZero.IsNat),
    (x : N, y : N, E : H Leq(x, y), P(x, y, E)) ->
    P(H succ(x), H succ(y), E leqSucc)) ->
  P(m, n, L)
let (leqZero.IsNat, P, pz, _) => pz(n)
let (L leqSucc[m := m', n := n'], P, pz, pi) =>
  pi(m', n', L, L ind(P, pz, pi))


val _pred\_Leq\_IsNat\Ty[N : Ty, H : N IsNat, m : N, n : N] :
  H Leq(m, n) -> H Leq(H pred(m), H pred(n))
let (leqZero.IsNat) =>
  H simplPredZero rew((x). H Leq(x, H pred(n)), leqZero.IsNat)
let (L leqSucc[m := m', n := n']) =>
  H simplPredSucc(m') rew(H Leq(_, H pred(H succ(n'))), _) do
  H simplPredSucc(n') rew(H Leq(m', _), L)


val _simplLeqSucc\_Leq\_IsNat\Ty[N : Ty, H : N IsNat, m : N, n : N] :
  H Leq(H succ(m), H succ(n)) -> H Leq(m, n)
let (L) =>
  H simplPredSucc(m) resp(H Leq(_, n), _) do
  H simplPredSucc(n) resp(H Leq(H pred(H succ(m)), _), L pred)


val _succLeq?\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (N, N -> Bool) -> N -> Bool
let (H) => (_, p). (n). H rec(n, false, (n', _). p(n'))


val _leq?\_IsNat\Ty[N : Ty] : N IsNat -> (N, N) -> Bool
let (H) => (m, n). H rec(m, const(true), H succLeq?)(n)


val _simplLeq?Zero\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (n : N) -> H leq?(H zero, n) = true
let (H) => (n).
  H simplRecZero(const(true), H succLeq?) ap (f). f(n)


val _simplLeq?Succ\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (m : N, n : N) ->
  H leq?(H succ(m), n) = H succLeq?(m, (n'). H leq?(m, n'))(n)
let (H) => (m, n).
  H simplRecSucc(m, const(true), H succLeq?) ap (f). f(n)


val _simplLeq?SuccZero\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (m : N) -> H leq?(H succ(m), H zero) = false
let (H) => (m).
  H simplLeq?Succ(m, H zero)
  @ H simplRecZero(false, (n', _). H leq?(m, n'))


val _simplLeq?SuccSucc\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (m : N, n : N) ->
  H leq?(H succ(m), H succ(n)) = H leq?(m, n)
let (H) => (m, n).
  H simplLeq?Succ(m, H succ(n))
  @ H simplRecSucc(n, false, (n', _). H leq?(m, n'))


val _leq?ToLeq\_IsNat\Ty[N : Ty] :
  (H : N IsNat) -> (m : N, n : N) ->
  ? H leq?(m, n) -> H Leq(m, n)
let (H) => (m, n). (L). H ind(m, P1, base1, step1)(n, L)
where
  val P1 : N -> Ty
  let (m) => (n : N, ? H leq?(m, n)) -> H Leq(m, n)

  val base1 : P1(H zero)
  let (n, _) => leqZero.IsNat

  val step1 : (m : N, P1(m)) -> P1(H succ(m))
  let (m, p1) => (n, L). H ind(n, P2, base2, step2)(L)
  where
    val P2 : N -> Ty
    let (n) => ? H leq?(H succ(m), n) -> H Leq(H succ(m), n)

    val base2 : P2(H zero)
    let (e) => case H simplLeq?SuccZero(m) resp(? _, e) of () end

    val step2 : (n : N, P2(n)) -> P2(H succ(n))
    let (n, p2) => (e).
      p1(n, H simplLeq?SuccSucc(m, n) resp(? _, e)) leqSucc
  end
end


val _plus\_IsNat\Ty[N : Ty] : (H : N IsNat) -> (N, N) -> N
let (H) => (m, n). H rec(n, m, (_, x). H succ(x))
