import "yu/RBTree/RBTree.yu"
import "yu/List/theorems.yu"


val _.rootColor\RBTree [A : Ty] [od : Ordering? A] :
  RBTree A od -> Color.RB
let leaf.RB => black.RB
let (_ .node _ _ c) => c


val _.pathCountBlackNodes\RBTree [A : Ty] [od : Ordering? A] :
  RBTree A od -> List Nat
let leaf.RB => 0 :: nil
let (t1 .node t2 _ red.RB) =>
  t1 .pathCountBlackNodes :+: t2 .pathCountBlackNodes
let (t1 .node t2 _ black.RB) =>
  (t1 .pathCountBlackNodes :+: t2 .pathCountBlackNodes) .map (++_)


val _.blackInvariant\RBTree [A : Ty] [od : Ordering? A] :
  RBTree A od -> Bool
let t =>
  case t .pathCountBlackNodes
  | nil => true
  | n :: ns => ns .accum true of a x => a && (x =? n)
  end


val _.redInvariant\RBTree [A : Ty] [od : Ordering? A]
  : RBTree A od -> Bool
let leaf.RB => true
let (t1 .node t2 _ black.RB) =>
  t1 .redInvariant && t2 .redInvariant
let (t1 .node t2 _ red.RB) =>
  t1 .rootColor .black? &&
  t2 .rootColor .black? &&
  t1 .redInvariant &&
  t2 .redInvariant


val _.invariant\RBTree [A : Ty] [od : Ordering? A]
  : RBTree A od -> Bool
let t => t .blackInvariant && t .redInvariant
