import "Ordering?.yu"
import "yu/Equivalence?/Equivalence?.yu"


val leToEqIsReflexive?.Ordering?[A : Ty] :
  (le : (A, A) -> Bool, le IsTotalPreorder?) ->
  leToEq?.Ordering?(le) IsReflexive?
let (le, isC $ _) => (x).
  case pullOutOp|.Bool[a := le(x, x), b := le(x, x)](isC(x, x))
  of in1(h) => h rew((t). ? (t & t), refl)
  of in2(h) => h rew((t). ? (t & t), refl)
  end


val _eqIsReflexive?\_Ordering?\Ty[A : Ty] :
  (R : A Ordering?) -> R eq? IsReflexive?
let (R) => (x).
  R isOrdering? eqIsCompatible(x, x) rew(? _, _) do
  leToEqIsReflexive?.Ordering?(R le?, R isOrdering? leIsTotalPreorder)(x)


val leToEqIsSymmetric?.Ordering?[A : Ty] :
  (le : (A, A) -> Bool, le IsTotalPreorder?) ->
  leToEq?.Ordering?(le) IsSymmetric?
let (le, isLe) => (x, y, eqxy). do
  b := pullOutOp&.Bool[a := le(x, y), b := le(y, x)](eqxy);
  pushInOp&.Bool(b 2 $ b 1)


val _eqIsSymmetric\_Ordering?\Ty[A : Ty] :
  (R : A Ordering?) -> R eq? IsSymmetric?
let (R) => (x, y, eqxy).
  R isOrdering? eqIsCompatible(y, x) rew(? _, _) do
  leToEqIsSymmetric?.Ordering?(R le?, R isOrdering? leIsTotalPreorder)
    (x, y, R isOrdering? eqIsCompatible(x, y) resp(? _, eqxy))


val leToEqIsTransitive?.Ordering?[A : Ty] :
  (le : (A, A) -> Bool, le IsTotalPreorder?) ->
  leToEq?.Ordering?(le) IsTransitive?
let (le, _ $ isT) => (x, y, z, eqxy, eqyz). do
  eqxy' := pullOutOp&.Bool[a := le(x, y), b := le(y, x)](eqxy);
  eqyz' := pullOutOp&.Bool[a := le(y, z), b := le(z, y)](eqyz);
  l := isT(x, y, z, eqxy' 1, eqyz' 1);
  r := isT(z, y, x, eqyz' 2, eqxy' 2);
  pushInOp&.Bool(l $ r)


val _eqIsTransitive?\_Ordering?\Ty[A : Ty] :
  (R : A Ordering?) -> R eq? IsTransitive?
let (R) => (x, y, z, eqxy, eqyz).
  R isOrdering? eqIsCompatible(x, z) rew(? _, _) do
  leToEqIsTransitive?.Ordering?(R le?, R isOrdering? leIsTotalPreorder)
    (x, y, z,
      R isOrdering? eqIsCompatible(x, y) resp(? _, eqxy),
      R isOrdering? eqIsCompatible(y, z) resp(? _, eqyz))


val leToEqIsEquivalence?.Ordering?[A : Ty] :
  (le : (A, A) -> Bool, le IsTotalPreorder?) ->
  leToEq?.Ordering?(le) IsEquivalence?
let (le, isLe) =>
    leToEqIsSymmetric?.Ordering?(le, isLe)
  $ leToEqIsReflexive?.Ordering?(le, isLe)
  $ leToEqIsTransitive?.Ordering?(le, isLe)


val _eqIsEquivalence?\_Ordering?\Ty[A : Ty] :
  (R : A Ordering?) -> R eq? IsEquivalence?
let (R) => R eqIsSymmetric $ R eqIsReflexive? $ R eqIsTransitive?


val _equivalence?\_Ordering?\Ty[A : Ty] : A Ordering? -> A Equivalence?
let (R) => mk.Equivalence?(R eq?, R eqIsEquivalence?)
