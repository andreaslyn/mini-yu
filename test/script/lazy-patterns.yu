
data LazyNat : Ty
| 0 : [] -> LazyNat
| p : [] -> [] -> LazyNat -> [] -> [] -> LazyNat

val plus : LazyNat & LazyNat -> LazyNat
let m 0 => m
let m (p n) => p (plus m n)

data LazyId [A : Ty] : A -> [] -> A -> Ty
| refl [a : A] [A : Ty] : [] -> LazyId a a

val 1 : LazyNat
let => p 0

val 2 : LazyNat
let => p 1

val 3 : LazyNat
let => p 2

val test-plus : LazyId 3 (plus 1 2)
let => refl

val test-lazy-absurd : LazyId 2 3 -> (A : Ty) & A -> A
let {}

val test : case 0 [] | 0 => Ty | p _ => {} end
let => {}
