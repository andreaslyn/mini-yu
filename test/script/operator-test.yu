
data Nat : Ty
| 0 : Nat
| (++\Nat) : Nat -> Nat

val 1 : Nat
let => ++ 0


data Nat' : Ty
| 0' : Nat'
| (++\Nat') : Nat' -> Nat'

val 1' : Nat'
let => ++ 0'


data (::\Ty) : Ty -> Ty
| nil[A : Ty] : :: A
| _::\::\Ty[A : Ty] : A & :: A -> :: A


val _+\::\Ty[A : Ty] : :: A & :: A -> :: A
let nil ys => ys
let (x :: xs) ys => x :: xs + ys


val _+\Nat : Nat & Nat -> Nat
let m 0 => m
let m (++ n) => ++ m + n


val _+\Nat' : Nat' & Nat' -> Nat'
let 0' n => n
let (++ m) n => m + ++ m


val 2 : Nat
let => 1 + 1

val 3 : Nat
let => _+\Nat 2 1

val 4 : Nat
let => (++\Nat)(3)


val 2' : Nat'
let => 1' + 1'

val 3' : Nat'
let => _+\Nat' 2' 1'

val 4' : Nat'
let => (++\Nat')(3')


val inc : Nat -> Nat
let => _ + 1


val inc' : Nat' -> Nat'
let => _ + 1'


val _.plus\Nat : Nat & Nat -> Nat
let => _+


val add : Nat & Nat -> Nat
let => _ + _


val _@\[A : Ty] [B : Ty] [C : Ty] : (B -> C) & (A -> B) -> A -> C
let g f => x => g(f(x))


val inc2 : Nat -> Nat
let => inc @ inc

val inc3 : Nat -> Nat
let => _@\ inc inc2


val _+'\Nat : ([] -> Nat) & Nat -> Nat
let n 0 => n
let n (++ m) => ++ (n +' m)

val inc4 : Nat -> Nat
let (n) => 4 +' n

val inc4-lazy : Nat -> Nat
let n => 4 +' n .plus 0
