import yu/prelude
| (...)

import yu/parallel
| parallel'

import L => yu/List
| List
| (...#List)

import N => yu/Nat
| Nat
| (...#Nat)

import yu/Lazy
| Lazy
| lazy
| (...#Lazy)

import Str => yu/Str


val printResult : Str || {} ->> {}
let (in1 msg) => ("error: " :+: msg) .println
let (in2 ()) => "ok" .println


val 100 : Nat
let => 10.N * 10.N

val 10000 : Nat
let => 100 * 100


val spawnLoop : Nat ->> List (Lazy of Str || {})
let 0.N => nil.L
let (++ n) =>
  parallel' (_ => n .println) :: spawnLoop n


val (.foreach#List) [A : Ty] : List A & (A ->> {}) ->> {}
let nil.L _ => ()
let (x :: xs) f => f x; xs .foreach f


val main : {} ->> {}
let () =>
  t1 := parallel' (_ => ('t :: '1 :: nil.Str) .println);
  t2 := parallel' (_ => ('t :: '2 :: nil.Str) .println);
  t3 := parallel' (_ => ('t :: '3 :: nil.Str) .println);
  t4 := parallel' (_ => ('t :: '4 :: nil.Str) .println);
  t5 := parallel' (_ => ('t :: '5 :: nil.Str) .println);
  t6 := parallel' (_ => ('t :: '6 :: nil.Str) .println);
  t7 := parallel' (_ => ('t :: '7 :: nil.Str) .println);
  printResult (t7 .force);
  printResult (t6 .force);
  printResult (t5 .force);
  printResult (t4 .force);
  spawnLoop (10.N * 10.N) .foreach of t => printResult of t .force
