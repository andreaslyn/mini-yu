import "yu/prelude/prelude.yu"

val gen-stream : Nat -> [] -> Stream Nat
let 0 => 0 :: nil.Stream
let (++ n) => ++ n :: gen-stream n

val 100 : Nat
let => 10 * 10

val 1000 : Nat
let => 100 * 10

val 10000 : Nat
let => 1000 * 10

val 100000 : Nat
let => 10000 * 10

val 1000000 : Nat
let => 100000 * 10

val 3000000 : Nat
let => 1000000 * 3

val streamFirstAndLast' : Stream Nat -> Nat && Nat
let nil.Stream => 0 $ 0
let (x :: xs) =>
  match xs []
  let nil.Stream => x $ x
  let _ :: _ => x $ streamLast xs
  end
where
  val streamLast : Stream Nat -> Nat
  let nil.Stream => 0
  let (x :: xs) =>
    match xs []
    let nil.Stream => x
    let _ :: _ => streamLast xs
    end
end

val streamFirstAndLast : ([] -> Stream Nat) -> Nat && Nat
let s => streamFirstAndLast' s

val sreverse' [A : Ty] : Stream A -> [] -> Stream A
let => aux0 nil.Stream
where
  val aux0 : ([] -> Stream A) -> Stream A -> [] -> Stream A
  let a => xs => aux a xs

  val aux : ([] -> Stream A) & Stream A -> [] -> Stream A
  let a nil.Stream => a
  let a (x :: xs) => aux (x :: a) xs
end

val sreverse [A : Ty] : ([] -> Stream A) -> [] -> Stream A
let s => sreverse' s

val main : {} ->> {}
let () =>
  xs := gen-stream 1000000;
  match streamFirstAndLast (sreverse' (sreverse' xs))
  let 0 $ 0 => "0" .println
  let _ $ 0 => "1" .println
  let 0 $ _ => "2" .println
  let _ $ _ => "3" .println
  end;
  match streamFirstAndLast (sreverse (sreverse xs))
  let 0 $ 0 => "0" .println
  let _ $ 0 => "1" .println
  let 0 $ _ => "2" .println
  let _ $ _ => "3" .println
  end
