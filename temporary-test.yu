

val _.id\Ty : Ty -> Ty
let X => X

val testid : Ty
let => Ty .id

val _.const\Ty : Ty & Ty -> Ty
let X _ => X

val testconst : Ty
let => Ty .const {}

val unitfun : {} -> {}
let (_) => ()

val testunitfun : {}
let => unitfun ()

val multifun0 : {} & ((Ty) -> Ty) & ((Ty -> Ty)) & (name : Ty) -> {}
let _ _ _ _ => ()

val duofun : {} & {} -> {}
let () () => ()

val testduofun : {}
let => duofun () ()

val funfun : {} -> {} -> {}
let => (x : {}) => B := Ty; (); y => (); u := (); u

val testfunfun : {}
let => funfun () ()

data Nat : Ty
let 0 : Nat
let (++_\Nat) : Nat -> Nat

val testoppat1 : Nat -> Nat
let (0) => ++ 0
let (++ n) => ++ ++ n

data Nat' : Ty
let 0' : Nat'
let succ' : Nat' -> Nat'

val testfunpat1 : Nat' -> Nat'
let (0') => succ' 0'
let (succ' n) => succ' (succ' n)

data Bi : Ty
let bi : Bi
let (++_\Bi) : Bi -> Bi -> Bi

val testoppat2 : Bi -> Bi
let bi => (++ bi) bi
let ((++ x) y) => (++ x) y

data Bi' : Ty
let bi' : Bi'
let bibi' : Bi' -> Bi' -> Bi'

val testfunpatCurrly : Bi' -> Bi'
let bi' => bibi' bi' bi'
let (bibi' x y) => bibi' x y

data Bi'' : Ty
let bi'' : Bi''
let bibi'' : Bi'' & Bi'' -> Bi''

val testfunpat2 : Bi'' -> Bi''
let bi'' => bibi'' bi'' bi''
let (bibi'' x y) => bibi'' x y


val testimp1 [A : Ty] : Ty
let => A

val testimp2 [A B : Ty] : Ty
let => B

val testimp2' [A : Ty] [B : {}] : Ty
let => A

val testimp2'' [A : Ty] [B : {}] : Ty
let [A := X] [B := ()] => X


val testapimp : Ty
let => testimp1 [A := {}]

val testapimp' : Ty
let => testimp2' [B := ()] [A := {}]


data List : Ty -> Ty
let nil [A B : Ty] : List A
let _:+_\List [A : Ty] : A & List A -> List A

val _.len\List [A : Ty] : List A -> Nat
let (nil [A := X] [B := Y]) => 0
let (_ :+ xs) => xs .len
