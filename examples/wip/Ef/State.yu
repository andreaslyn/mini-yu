import "Handler.yu"


data State : Ty -> Signa
let getOp[S : Ty] : State(S)(shift.Op, S)
let putOp[S : Ty] : S -> State(S)(shift.Op, Unit)


val _get\In[S : Ty, Us : Signa List, Ps : Ef List] :
  (In(State(S), Us), AreEfs(Us, Ps)) -> Ps :> S
let => performShift(getOp, _, _)


val _put\In[S : Ty, Us : Signa List, Ps : Ef List] :
  (In(State(S), Us), AreEfs(Us, Ps), S) -> Ps :> Unit
let (ii, ar, s) => performShift(putOp(s), ii, ar)


val StateC : Ty -> (Ef List, Ty) -> Ty
let (S) => (Ps, A). S -> Ps :> S & A


val env.StateC : Ty -> Ty -> Ty
let (S) => S & _


val isFunctorEnv.StateC[S : Ty] : IsFunctor(env.StateC(S))
let (t, f, A, B) => t 1 $ f (t 2)


val unit.StateC[S : Ty, Us : Signa List] :
  (A : Ty, Ps : Ef List, AreEfs(Us, Ps), A) -> Ps :> StateC(S)(Ps, A)
let (A, Ps, arePs, a) => pure.Comp(arePs, (s). pure.Comp(arePs, s $ a))


val modify.StateC[S : Ty, Us : Signa List] : 
  ( A; B : Ty, Ps : Ef List, AreEfs(Us, Ps)
  , (env.StateC(S)(Unit), RunCarrier(Us, StateC(S), env.StateC(S))) ->
    Ps :> env.StateC(S)(A)
  , A -> Ps :> StateC(S)(Ps, B)
  ) -> Ps :> StateC(S)(Ps, B)
let (A, B, Ps, are, scope, k) =>
  pure.Comp(are, _) (s). do
  bind.Comp(are, scope(s $ unit, runC(s)), _) (t). do
  bind.Comp(are, k(t 2), (k'). k'(t 1))
where
  val runC : S -> RunCarrier(Us, StateC(S), env.StateC(S))
  let (s) => (X, Qs, areQ, q). bind.Comp(areQ, q, (f). f(s))
end


val isCarrier.StateC : (S : Ty, Us : Signa List) -> IsCarrier(StateC(S), Us)
let (S, Us) =>
  mk.IsCarrier(env.StateC(S), isFunctorEnv.StateC,
    unit.StateC, modify.StateC)


val shift.StateC[S : Ty, Us : Signa List] :
  (A; R : Ty, Ps : Ef List, AreEfs(Us, Ps),
    State(S)(shift.Op, A), A -> Ps :> StateC(S)(Ps, R)) ->
  Ps :> StateC(S)(Ps, R)
let (A, R, Ps, arePs, getOp, k) =>
  pure.Comp(arePs, _) (s). bind.Comp(arePs, k(s), (f). f(s))
let (A, R, Ps, arePs, putOp(s), k) =>
  pure.Comp(arePs, _) (_). bind.Comp(arePs, k(unit), (f). f(s))


val reset.StateC[S : Ty, Us : Signa List] :
  ( F : Ty -> Ty, B; R : Ty, n : Arity
  , Ps : Ef List, AreEfs(Us, Ps), IsFunctor(F)
  , State(S)(reset.Op(n), B), Dom(Nest(StateC(S), F, Ps), n)
  , F(Unit), F(B) -> Ps :> StateC(S)(Ps, R)
  ) -> Ps :> StateC(S)(Ps, R)
let (F, B, R, n, Ps, arePs, isF, (), dm, en, k)


val handler.StateC :
  (S : Ty, Us : Signa List) ->
  Handler(isCarrier.StateC(S, Us), State(S), Us)
let (S, Us) => mk.Handler(shift.StateC, reset.StateC)


val run.StateC[S : Ty, Us : Signa List, Ps : Ef List, A : Ty] :
  (AreEfs(Us, Ps),
    (St : Ef, AreEfs(State(S) :: Us, St :: Ps)) -> (St :: Ps) :> A, S) ->
  Ps :> S & A
let (arePs, scope, s) =>
  bind.Comp(arePs, handler.StateC(S, Us) handle(arePs, scope), (f). f(s))


val eval.StateC[S : Ty, Us : Signa List, Ps : Ef List, A : Ty] :
  (AreEfs(Us, Ps),
    (St : Ef, AreEfs(State(S) :: Us, St :: Ps)) -> (St :: Ps) :> A, S) ->
  Ps :> A
let (arePs, scope, s) =>
  map[A := S & A](isFunctor.Comp(arePs), run.StateC(arePs, scope, s), _ 2)


val exec.StateC[S : Ty, Us : Signa List, Ps : Ef List, A : Ty] :
  (AreEfs(Us, Ps),
    (St : Ef, AreEfs(State(S) :: Us, St :: Ps)) -> (St :: Ps) :> A, S) ->
  Ps :> S
let (arePs, scope, s) =>
  map[A := S & A](isFunctor.Comp(arePs), run.StateC(arePs, scope, s), _ 1)
