import "Monad.yu"
import "Signa.yu"


data.. Ef : Ty
let mk.Ef : (Signa, (Ef List, Ty) -> Ty, Ty) -> Ef


val _:>_\Ty : (Ef List, Ty) -> Ty
let (nil, A) => A
let (mk.Ef(_, T, R) :: Ps, A) => ContT(T(Ps, R), Ps :> _)(A)


data.. AreEfs : (Signa List, Ef List) -> Ty
let _::_\AreEfs[U : Signa, Us : Signa List, R : Ty,
    T : (Ef List, Ty) -> Ty, isC : IsCarrier(T, Us), Ps : Ef List] : 
  (Handler(isC, U, Us), AreEfs(Us, Ps)) ->
  AreEfs(U :: Us, mk.Ef(U, T, R) :: Ps)
let nil.AreEfs : AreEfs(nil, nil)


data.. IsCarrier : ((Ef List, Ty) -> Ty, Signa List) -> Ty
let mk.IsCarrier[T : (Ef List, Ty) -> Ty, Us : Signa List] :
  ( En : Ty -> Ty
  , IsFunctor(En)
  , (A : Ty, Ps : Ef List, AreEfs(Us, Ps), A) -> Ps :> T(Ps, A)
  , ( A; B : Ty, Ps : Ef List, AreEfs(Us, Ps)
    , (En(Unit), RunCarrier(Us, T, En)) -> Ps :> En(A)
    , A -> Ps :> T(Ps, B)
    ) -> Ps :> T(Ps, B)
  ) -> IsCarrier(T, Us)


val RunCarrier : (Signa List, (Ef List, Ty) -> Ty, Ty -> Ty) -> Ty
let (Us, T, En) =>
  (X : Ty, Qs : Ef List, AreEfs(Us, Qs), Qs :> T(Qs, X)) -> Qs :> En(X)


val _Env\IsCarrier[T : (Ef List, Ty) -> Ty, Us : Signa List] :
  IsCarrier(T, Us) -> Ty -> Ty
let (mk.IsCarrier(En, _, _, _)) => En


val _isFunctorEnv\IsCarrier[T : (Ef List, Ty) -> Ty, Us : Signa List] :
  (isC : IsCarrier(T, Us)) -> IsFunctor(isC Env)
let (mk.IsCarrier(_, isF, _, _)) => isF


val _unit\IsCarrier[T : (Ef List, Ty) -> Ty, Us : Signa List,
    Ps : Ef List, A : Ty] :
  (IsCarrier(T, Us), AreEfs(Us, Ps), A) -> Ps :> T(Ps, A)
let (mk.IsCarrier(_, _, u, _), As, a) => u(A, Ps, As, a)


val _modify\IsCarrier[T : (Ef List, Ty) -> Ty, Us : Signa List,
    Ps : Ef List, A; B : Ty] :
  ( isC : IsCarrier(T, Us)
  , AreEfs(Us, Ps)
  , (isC Env(Unit), RunCarrier(Us, T, isC Env)) -> Ps :> isC Env(A)
  , A -> Ps :> T(Ps, B)
  ) -> Ps :> T(Ps, B)
let (mk.IsCarrier(_, _, _, m), As, e, u) => m(A, B, Ps, As, e, u)


val Scope : Signa List -> Ty -> Ty
let (Us) => (A). (Ps : Ef List, AreEfs(Us, Ps)) -> Ps :> A


val Nest : ((Ef List, Ty) -> Ty, Ty -> Ty, Ef List) -> Ty -> Ty
let (T, F, Ps) => (A). Ps :> T(Ps, F(A))


data.. Handler[T : (Ef List, Ty) -> Ty, Us : Signa List] : 
  (IsCarrier(T, Us), Signa, Signa List) -> Ty
let mk.Handler[T : (Ef List, Ty) -> Ty,
    U : Signa, Us : Signa List, isC : IsCarrier(T, Us)] :
  ( ( A; R : Ty
    , Ps : Ef List
    , AreEfs(Us, Ps)
    , U(shift.Op, A)
    , A -> Ps :> T(Ps, R)
    ) -> Ps :> T(Ps, R)
  , ( F : Ty -> Ty, B; R : Ty, n : Arity
    , Ps : Ef List
    , AreEfs(Us, Ps)
    , IsFunctor(F)
    , U(reset.Op(n), B)
    , Dom(Nest(T, F, Ps), n)
    , F(Unit)
    , F(B) -> Ps :> T(Ps, R)
    ) -> Ps :> T(Ps, R)
  ) -> Handler(isC, U, Us)


val _shift\Handler[T : (Ef List, Ty) -> Ty,
    U : Signa, Us : Signa List, isC : IsCarrier(T, Us),
    A; R : Ty, Ps : Ef List] :
  ( Handler(isC, U, Us)
  , AreEfs(Us, Ps)
  , U(shift.Op, A)
  , A -> Ps :> T(Ps, R)
  ) -> Ps :> T(Ps, R)
let (mk.Handler(u, _), As, f, k) => u(A, R, Ps, As, f, k)


val _reset\Handler[T : (Ef List, Ty) -> Ty,
    U : Signa, Us : Signa List, isC : IsCarrier(T, Us),
    F : Ty -> Ty, B; R : Ty, n : Arity, Ps : Ef List] :
  ( Handler(isC, U, Us)
  , AreEfs(Us, Ps)
  , IsFunctor(F)
  , U(reset.Op(n), B)
  , Dom(Nest(T, F, Ps), n)
  , F(Unit)
  , F(B) -> Ps :> T(Ps, R)
  ) -> Ps :> T(Ps, R)
let (mk.Handler(_, r), As, isF, u, d, c, k) =>
  r(F, B, R, n, Ps, As, isF, u, d, c, k)


val eval.Comp[R : Ty, Ps : Ef List] : (AreEfs(nil, Ps), Ps :> R) -> R
let (nil.AreEfs, x) => x


val isFunctor.Comp[Us : Signa List, Ps : Ef List] :
  AreEfs(Us, Ps) -> IsFunctor(Ps :> _)
let (_::_[R := R, Ps := Ps', T := T](_, _)) =>
  isFunctor.ContT(T(Ps', R), Ps' :> _)
let (nil.AreEfs) => isFunctor.id


val pure.Comp[Us : Signa List, Ps : Ef List, A : Ty] :
  (AreEfs(Us, Ps), A) -> Ps :> A
let (_::_[R := R, Ps := Ps', T := T](_, _), x) =>
  pure.ContT(T(Ps', R), Ps' :> _, x)
let (nil.AreEfs, x) => x


val bind.Comp[Us : Signa List, Ps : Ef List, A; B : Ty] :
  (AreEfs(Us, Ps), Ps :> A, A -> Ps :> B) -> Ps :> B
let (_::_[R := R, Ps := Ps', T := T](_, _), x, f) =>
  bind.ContT(T(Ps', R), Ps' :> _, x, f)
let (nil.AreEfs, x, f) => f(x)


val isMonad.Comp[Us : Signa List, Ps : Ef List] :
  AreEfs(Us, Ps) -> IsMonad(Ps :> _)
let (_::_[R := R, Ps := Ps', T := T](_, _)) =>
  isMonad.ContT(T(Ps', R), Ps' :> _)
let (nil.AreEfs) => isMonad.id
