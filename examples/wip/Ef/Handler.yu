import "Ef.yu"


val _handle\Handler[U : Signa, Us : Signa List, T : (Ef List, Ty) -> Ty,
    R : Ty, Ps : Ef List, isC : IsCarrier(T, Us)] :
  (Handler(isC, U, Us), AreEfs(Us, Ps),
    (P : Ef, AreEfs(U :: Us, P :: Ps)) -> (P :: Ps) :> R) ->
  Ps :> T(Ps, R)
let (han, are, c) => handle.Handler(han, are, c(mk.Ef(U, T, R), han :: are))


val handle.Handler[U : Signa, Us : Signa List, T : (Ef List, Ty) -> Ty,
    R : Ty, Ps : Ef List, isC : IsCarrier(T, Us)] :
  (Handler(isC, U, Us), AreEfs(Us, Ps), (mk.Ef(U, T, R) :: Ps) :> R) ->
  Ps :> T(Ps, R)
let (han, are, c) => c(isC unit(are, _))


val performShift[U : Signa, Us : Signa List, Ps : Ef List, A : Ty] :
  (U(shift.Op, A), In(U, Us), AreEfs(Us, Ps)) -> Ps :> A
let (op, h there, _ :: are) =>
  (k). bind.Comp(are, performShift(op, h, are), k)
let (op, here.In, han :: are) =>
  (k). han shift(are, op, k)
let (op, inject.In(i), han :: are) =>
  (k). han shift(are, i(shift.Op, A, op), k)


val performReset
    [U : Signa, Us : Signa List, B : Ty, n : Arity, Ps : Ef List] :
  (U(reset.Op(n), B), In(U, Us), AreEfs(Us, Ps), Dom(Scope(Us), n)) ->
  Ps :> B
let (op, isIn, are, dm) =>
  handleLoop[G := id](isFunctor.id, isIn, are, unit, dm)
where
  val handleLoop[Us' : Signa List, Ps' : Ef List, G : Ty -> Ty] :
    ( IsFunctor(G)
    , In(U, Us')
    , AreEfs(Us', Ps')
    , G(Unit)
    , Dom(Scope(Us') @ G, n)
    ) -> Ps' :> G(B)
  let (isF, is there, han :: are, st, scope) =>
    handleThere[G := G](are, han, isF, is, st, scope)
  let (isF, here.In,  han :: are, st, scope) =>
    handleHere[G := G](are, han, isF, op, st, scope)
  let (isF, inject.In(i), han :: are, st, scope) =>
    handleHere[G := G](are, han, isF, i(reset.Op(n), B, op), st, scope)

  val handleThere[U' : Signa, Us' : Signa List,
      T' : (Ef List, Ty) -> Ty, isC : IsCarrier(T', Us'),
      R' : Ty, Ps' : Ef List, G : Ty -> Ty] :
    ( AreEfs(Us', Ps')
    , Handler(isC, U', Us')
    , IsFunctor(G)
    , In(U, Us')
    , G(Unit)
    , Dom(Scope (U' :: Us') @ G, n)
    ) -> (mk.Ef(U', T', R') :: Ps') :> G(B)
  let (are, han, isF, isIn, st, scope) =>
    (k). isC modify(are, (e, r). con(e, (X, Qs, a, c). r(G(X), Qs, a, c)), k)
  where
    val con :
      ( isC Env(Unit)
      , (X : Ty
        , Qs : Ef List
        , AreEfs(Us', Qs)
        , Qs :> T'(Qs, G(X))
        ) -> Qs :> isC Env(G(X))
      ) -> Ps' :> isC Env(G(B))
    let (e, tr) =>
      handleLoop[G := isC Env @ G]
        ( isFunctor.@(isC isFunctorEnv, isF)
        , isIn
        , are
        , map[F := isC Env](isC isFunctorEnv, e, (_). st)
        , scope' )
    where
      val scope' : Dom(Scope(Us') @ isC Env @ G, n)
      let => scope map(scopeMap)

      val scopeMap :
        (A : Ty, Scope(U' :: Us')(G(A))) ->
        Scope(Us')(isC Env(G(A)))
      let (A, x) => (Qs, a).
        tr(A, Qs, a,
          handle.Handler(han, a, x(mk.Ef(U', T', G(A)) :: Qs, han :: a)))
    end
  end

  val handleHere[U' : Signa, Us' : Signa List,
      T' : (Ef List, Ty) -> Ty, isC : IsCarrier(T', Us'),
      R' : Ty, Ps' : Ef List, G : Ty -> Ty] :
    ( AreEfs(Us', Ps')
    , Handler(isC, U', Us')
    , IsFunctor(G)
    , U'(reset.Op(n), B)
    , G(Unit)
    , Dom(Scope (U' :: Us') @ G, n)
    ) -> (mk.Ef(U', T', R') :: Ps') :> G(B)
  let (are, han, isF, op, st, scope) => 
    (k). han reset[F := G](are, isF, op, scope map(scopeMap), st, k)
    where
      val scopeMap :
        (A : Ty, Scope(U' :: Us')(G(A))) -> Nest(T', G, Ps')(A)
      let (A, x) =>
        handle.Handler(han, are, x(mk.Ef(U', T', G(A)) :: Ps', han :: are))
    end
end
