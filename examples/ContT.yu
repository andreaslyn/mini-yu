import "yu/prelude.yu"


data _IsMonad\_->_ : (Ty -> Ty) -> Ty
let isMonad[M : Ty -> Ty] : (
  (A, A : Ty) -> M(A),
  (M(A), [] -> A -> M(B), A : Ty, B : Ty) -> M(B)
) -> M IsMonad


val _pure\_IsMonad\_->_[A : Ty, M : Ty -> Ty] : M IsMonad -> A -> M(A)
let (isMonad(r, _)) => r(_, A)


val _bind\_IsMonad\_->_[A; B : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> ([] -> A -> M(B)) -> M(B)
let (isMonad(_, b), a) => (f). b(a, f, A, B)


val idIsMonad : id IsMonad
let => isMonad(_:!_, bind)
where
  val bind : (A, [] -> A -> B, A; B : Ty) -> B
  let (x, f, A, B) => f[](x)
end


data _ContT\Ty : (Ty, Ty, M : Ty -> Ty, M IsMonad) -> Ty
let contT[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  ((A -> M(R)) -> M(R)) -> A ContT(R, M, isM)


val _ap\_ContT\Ty[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  (A ContT(R, M, isM), A -> M(R)) -> M(R)
let (contT(c), k) => c(k)


val _eval\_ContT\Ty[R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  R ContT(R, M, isM) -> M(R)
let (c) => c ap(isM pure)


val pure.ContT[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  A -> A ContT(R, M, isM)
let (a) => contT (k). k(a)


val _>>=_\_ContT\Ty[A; B; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  (A ContT(R, M, isM), [] -> A -> B ContT(R, M, isM)) -> B ContT(R, M, isM)
let (x, f) => contT (k). x ap (a). f[](a) ap(k)


val contTIsMonad[R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  _ ContT\Ty(R, M, isM) IsMonad
let => isMonad((a, A). pure.ContT(a), (x, f, A, B). x >>= f)


val _lift\_IsMonad\_->_[A; R : Ty, M : Ty -> Ty] :
  (isM : M IsMonad, M(A)) -> A ContT(R, M, isM)
let (isM, x) => contT (k). isM bind(x)([]. k)


val example6 : Nat -> Bool
let (x) =>
  _eval do
  timesThree(x) >>= (y). do
  greaterThanTen(y) >>= (z). do
  pure.ContT(z)
where
  val timesThree[R : Ty] : Nat -> Nat ContT(R, id, idIsMonad)
  let (x) => contT (k). k(3 * x)

  val greaterThanTen[R : Ty] : Nat -> Bool ContT(R, id, idIsMonad)
  let (y) => contT (k). k (10 <? y)
end


val _HandlerFun\_->_ : (Ty -> Ty, Ty, Ty -> Ty) -> Ty
let (Sig, R, M) => (Sig(A), A : Ty, A -> M(R)) -> M(R)


data _Handler\_->_ : (Ty -> Ty, Ty, M : Ty -> Ty, isM : M IsMonad) -> Ty
let mkHandler[Sig : Ty -> Ty, R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  Sig HandlerFun(R, M) -> Sig Handler(R, M, isM)


val _ap\_Handler\_->_[Sig : Ty -> Ty, R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  Sig Handler(R, M, isM) -> Sig HandlerFun(R, M)
let (mkHandler(f)) => f


data StateSigna : Ty -> Ty -> Ty
let getOp[A : Ty] : StateSigna(A)(A)
let putOp[A : Ty] : A -> StateSigna(A)(Unit)


val stateHandler[A; S : Ty, M : Ty -> Ty, isM : M IsMonad] :
  StateSigna(S) Handler(S -> M(A), M, isM)
let => mkHandler(hand)
where
  val hand : StateSigna(S) HandlerFun(S -> M(A), M)
  let (getOp, _, k) => isM pure (s). isM bind(k(s)) (k). k(s)
  let (putOp(x), _, k) => isM pure (_). isM bind(k(unit)) (k). k(x)
end


val _Ef\_->_ : (Ty -> Ty, Ty, M : Ty -> Ty, M IsMonad) -> Ty
let (Sig, R, M, isM) => (B : Ty, Sig(B)) -> B ContT(R, M, isM)


val _handle\_Handler\_->_[A; R : Ty, Sig; M : Ty -> Ty, isM : M IsMonad] :
  (Sig Handler(R, M, isM), Sig Ef(R, M, isM) -> A ContT(R, M, isM)) -> 
  A ContT(R, M, isM)
let (h, c) => contT (k). c((B, x). contT (f). h ap(x, B, f)) ap(k)


val _runStateHandler\_IsMonad\_->_[A; S : Ty, M : Ty -> Ty]
  : (isM : M IsMonad, S) ->
    (StateSigna(S) Ef(S -> M(S & A), M, isM) -> A ContT(S -> M(S & A), M, isM)) ->
    M(S & A)
let (isM, s) => (c).
    isM bind(
      stateHandler handle(c)
      ap (a). isM pure (s). isM pure(s $ a)) (f).
    f(s)


val plusWithStateEffect : (Nat, Nat) -> Nat & Nat
let (m, n) =>
  idIsMonad runStateHandler(n) (st).
  st(Nat, getOp) >>= (n).
  st(Unit, putOp(m + n)) >>= (_).
  st(Nat, getOp) >>= (r).
  pure.ContT(r)


data PartialSigna : Ty -> Ty
let failOp[A : Ty] : PartialSigna(A)


val partialHandler[A : Ty, M : Ty -> Ty, isM : M IsMonad] :
  PartialSigna Handler(? A, M, isM)
let => mkHandler(hand)
where
  val hand : PartialSigna HandlerFun(? A, M)
  let (failOp, _, k) => isM pure(no)
end


val _runPartialHandler\_IsMonad\_->_[A : Ty, M : Ty -> Ty] :
  (isM : M IsMonad) ->
  (PartialSigna Ef(? A, M, isM) -> A ContT(? A, M, isM)) ->
  M(? A)
let (isM) => (c). partialHandler handle(c) ap(isM pure @ yes)


val testPartialEffect : (Nat, Nat) -> ? Nat
let (x, y) =>
  idIsMonad runPartialHandler (pa).
  partialHandler handle (pa).
  get(pa, x) >>= (x).
  get(pa, y) >>= (y).
  pure.ContT(x)
where
  val get :
    (PartialSigna Ef(? Nat, id, idIsMonad), Nat) ->
    Nat ContT(? Nat, id, idIsMonad)
  let (pa, n) =>
    if(n =? 0)
    then(pa(Nat, failOp))
    else(pure.ContT(n))
end


val partialPlusWithStateEffect : (Nat, Nat) -> ? (Nat & Nat)
let (m, n) =>
  idIsMonad runPartialHandler (pa).
  contTIsMonad runStateHandler(0) (st).
  get(pa, lift, m) >>= (m).
  st(Unit, putOp(m)) >>= (_).
  get(pa, lift, n) >>= (n).
  st(Nat, getOp) >>= (m).
  st(Unit, putOp(m + n)) >>= (_).
  st(Nat, getOp) >>= (r).
  pure.ContT(r)
where
  val Lift : (Ty, M : Ty -> Ty, M IsMonad) -> Ty
  let (A, M, isM) =>
    (X : Ty, X ContT(? A, M, isM)) ->
    RetM(X, A, _ ContT(? A, M, isM), contTIsMonad)

  val lift[A : Ty, M : Ty -> Ty, isM : M IsMonad] : Lift(A, M, isM)
  let (X, c) => contTIsMonad lift(c)

  val RetM : (Ty, Ty, F : Ty -> Ty, F IsMonad) -> Ty
  let (X, A, F, isF) => X ContT(Nat -> F(A), F, isF)

  val get[A : Ty, M : Ty -> Ty, isM : M IsMonad] :
    (PartialSigna Ef(? A, M, isM), Lift(A, M, isM), Nat) ->
    RetM(Nat, A, _ ContT(? A, M, isM), contTIsMonad)
  let (pa, l, n) =>
    if(n =? 0)
    then(l(Nat, pa(Nat, failOp)))
    else(pure.ContT(n))
end


val plusPartialWithStateEffect : (Nat, Nat) -> Nat & ? Nat
let (m, n) =>
  idIsMonad runStateHandler(0) (st).
  contTIsMonad runPartialHandler (pa).
    work(st, pa)
where
  val work :
    (st : StateSigna(Nat) Ef(Nat -> Nat & ? Nat, id, idIsMonad),
     pa : PartialSigna Ef(? Nat,
            _ ContT(Nat -> Nat & ? Nat, id, idIsMonad), contTIsMonad)) ->
    RetM(Nat, Nat,
      _ ContT(? Nat, _ ContT(Nat -> Nat & ? Nat, id, idIsMonad), contTIsMonad),
      contTIsMonad)
  let (st, pa) =>
    get(pa, lift, m) >>= (m).
    contTIsMonad lift(st(Unit, putOp(m))) >>= (_).
    get(pa, lift, n) >>= (n).
    contTIsMonad lift(st(Nat, getOp)) >>= (m).
    contTIsMonad lift(st(Unit, putOp(m + n))) >>= (_).
    contTIsMonad lift(st(Nat, getOp)) >>= (r).
    pure.ContT(r)

  val Lift : (Ty, M : Ty -> Ty, M IsMonad) -> Ty
  let (A, M, isM) =>
    (X : Ty, X ContT(? A, M, isM)) ->
    RetM(X, A, _ ContT(? A, M, isM), contTIsMonad)

  val lift[A : Ty, M : Ty -> Ty, isM : M IsMonad] : Lift(A, M, isM)
  let (X, c) => c

  val RetM : (Ty, Ty, F : Ty -> Ty, F IsMonad) -> Ty
  let (X, A, F, isF) => F(X)

  val get[A : Ty, M : Ty -> Ty, isM : M IsMonad] :
    (PartialSigna Ef(? A, M, isM), Lift(A, M, isM), Nat) ->
    RetM(Nat, A, _ ContT(? A, M, isM), contTIsMonad)
  let (pa, l, n) =>
    if(n =? 0)
    then(l(Nat, pa(Nat, failOp)))
    else(pure.ContT(n))
end


val main : () ->> Unit
let () =>
  partialPlusWithStateEffect(2, 0) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(0, 2) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(2, 2) str((p). p str(_str, (x, _). x str)) println;
  plusPartialWithStateEffect(2, 0) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(0, 2) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(2, 2) str(_str, (x, _). x str(_str)) println
