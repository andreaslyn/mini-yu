import "yu/prelude.yu"


data _IsMonad\_->_ : (Ty -> Ty) -> Ty
let isMonad[M : Ty -> Ty] : (
  (A, A : Ty) -> M(A),
  (M(A), A -> M(B), A : Ty, B : Ty) -> M(B)
) -> M IsMonad


val _pure\_IsMonad\_->_[A : Ty, M : Ty -> Ty] : M IsMonad -> A -> M(A)
let (isMonad(r, _)) => r(_, A)


val _bind\_IsMonad\_->_[A; B : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> (A -> M(B)) -> M(B)
let (isMonad(_, b), a) => (f). b(a, f, A, B)


val idIsMonad : id IsMonad
let => isMonad(_:!_, bind)
where
  val bind : (A, A -> B, A; B : Ty) -> B
  let (x, f, A, B) => f(x)
end


data _ContT\Ty : (Ty, Ty, M : Ty -> Ty) -> Ty
let contT[A; R : Ty, M : Ty -> Ty] :
  ((A -> M(R)) -> M(R)) -> A ContT(R, M)


val _finally\_ContT\Ty[A; R : Ty, M : Ty -> Ty] : (A ContT(R, M), A -> M(R)) -> M(R)
let (contT(c), k) => c(k)


val pure.ContT[A; R : Ty, M : Ty -> Ty] : A -> A ContT(R, M)
let (a) => contT (k). k(a)


val _>>=_\_ContT\Ty[A; B; R : Ty, M : Ty -> Ty]:
  (A ContT(R, M), A -> B ContT(R, M)) -> B ContT(R, M)
let (x, f) => contT (k). x finally (a). f(a) finally(k)


val contTIsMonad[R : Ty, M : Ty -> Ty] : _ ContT\Ty(R, M) IsMonad
let => isMonad((a, A). pure.ContT(a), (x, f, A, B). x >>= f)


val _lift\_IsMonad\_->_[A; R : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> A ContT(R, M)
let (isM, x) => contT do isM bind(x)


data _Ef\_->_ : (Ty -> Ty) -> Ty
let mk.Ef[Sig : Ty -> Ty] : Ty -> Sig Ef


val _Ty\_Ef\_->_[Sig : Ty -> Ty] : Sig Ef -> Ty
let (mk.Ef(R)) => R


data EfList : Ty
let nil.EfList : EfList
let _::_\EfList[Sig : Ty -> Ty] : (Sig Ef, EfList) -> EfList


val _Signas\EfList : EfList -> (Ty -> Ty) List
let (nil.EfList) => nil
let (_::_[Sig := Sig](_, ps)) => Sig :: ps Signas


data _HasSignas\EfList : (EfList, (Ty -> Ty) List) -> Ty
let nilSignas.Ef : nil.EfList HasSignas(nil)
let _cons\_HasSignas\EfList[Sig : Ty -> Ty, p : Sig Ef,
    Sigs : (Ty -> Ty) List, ps : EfList] :
  ps HasSignas(Sigs) -> (p :: ps) HasSignas(Sig :: Sigs)


val _hasSignas\EfList : (ps : EfList) -> ps HasSignas(ps Signas)
let (nil.EfList) => nilSignas.Ef
let (p :: ps) => ps hasSignas cons


val _tail!\EfList : EfList -> EfList
let (nil.EfList) => nil.EfList
let (_ :: ps) => ps


data _Has\EfList[Sig : Ty -> Ty] : (EfList, Sig Ef) -> Ty
let here.Has[ps : EfList, Sig : Ty -> Ty, p : Sig Ef] :
  (p :: ps) Has(p)
let _there\_Has\EfList[ps : EfList, Sigp; Sigq : Ty -> Ty, p : Sigp Ef, q : Sigq Ef] :
  ps Has(p) -> (q :: ps) Has(p)


val _PreComp\EfList : EfList -> Ty -> Ty
let (nil.EfList) => id
let (p :: ps) => _ ContT(p Ty, ps PreComp)


val pure.PreComp[ps : EfList, A : Ty] : A -> ps PreComp(A)
let [ps := nil.EfList] => id
let [ps := p :: ps] => pure.ContT


val bind.PreComp[ps : EfList, A; B : Ty] :
  ps PreComp(A) -> (A -> ps PreComp(B)) -> ps PreComp(B)
let [ps := nil.EfList] => (a). (f). f(a)
let [ps := p :: ps] => (a). (f). a >>= f


val isMonad.PreComp[ps : EfList] : ps PreComp IsMonad
let => isMonad((a, A). pure.PreComp(a), (x, f, A, B). bind.PreComp(x)(f))


data _Handled\_Ef\_->_[Sig : Ty -> Ty] : (Sig Ef, EfList) -> Ty
let mkHandled.Ef[Sig : Ty -> Ty, Sigs : (Ty -> Ty) List,
    p : Sig Ef, ps : EfList, F : (Ty, EfList) -> Ty] : (
  (A : Ty, Sig(A)) -> A ContT(p Ty, ps PreComp),
  ps HasSignas(Sigs),
  Sig Handled(F, Sigs),
  & (R). p Ty = F(R, ps)
) -> p Handled(ps)


val _Signas\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  p Handled(ps) -> (Ty -> Ty) List
let (mkHandled.Ef[Sigs := Sigs](_, _, _, _)) => Sigs


val signasIsSignasImpl.Ef[Sigs : (Ty -> Ty) List, ts; ps : EfList] :
  (ps HasSignas(Sigs), ts HasSignas(ps Signas)) -> ts HasSignas(Sigs)
let (nilSignas.Ef, nilSignas.Ef) => nilSignas.Ef
let (h1 cons, h2 cons) => signasIsSignasImpl.Ef(h1, h2) cons


val _signasIsSignas\_Handled\_Ef\_->_[
    Sig : Ty -> Ty, p : Sig Ef, ts; ps : EfList] :
  (h : p Handled(ps), ts HasSignas(ps Signas)) -> ts HasSignas(h Signas)
let (mkHandled.Ef(_, h1, _, _), h2) => signasIsSignasImpl.Ef(h1, h2)


val _Ret\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  p Handled(ps) -> (Ty, EfList) -> Ty
let (mkHandled.Ef[F := F](_, _, _, _)) => F


val _ap\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  p Handled(ps) -> (A : Ty, Sig(A)) -> A ContT(p Ty, ps PreComp)
let (mkHandled.Ef(f, _, _, _)) => f


val _hasSignas\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (h : p Handled(ps)) -> ps HasSignas(h Signas)
let (mkHandled.Ef(_, hs, _, _)) => hs


val _handled\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (h : p Handled(ps)) -> Sig Handled(h Ret, h Signas)
let (mkHandled.Ef(_, _, hd, _)) => hd


val _retIsRet\_Handled\_Ef\_->_[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (h : p Handled(ps)) -> & (R). p Ty = h Ret(R, ps)
let (mkHandled.Ef(_, _, _, r)) => r


data.. _CompDom\EfList : EfList -> Ty
let nil.CompDom : nil.EfList CompDom
let _::_\_CompDom\EfList[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (p Handled(ps), ps CompDom) -> (p :: ps) CompDom


data.. _~_\Ty : (Ty, EfList) -> Ty
let mk.Comp[ps : EfList, A : Ty] : (ps CompDom -> ps PreComp(A)) -> A ~ ps


val _head\_CompDom\EfList[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (p :: ps) CompDom -> p Handled(ps)
let (h :: _) => h


val _tail!\_CompDom\EfList[ps : EfList] : ps CompDom -> ps tail! CompDom
let (nil.CompDom) => nil.CompDom
let (_ :: ds) => ds


val _pr\_~_\Ty[ps : EfList, A : Ty] : (A ~ ps, ps CompDom) -> ps PreComp(A)
let (mk.Comp(c), s) => c(s)


val _ap\_~_\Ty[ps : EfList, A; R : Ty, Sig : Ty -> Ty] : do
  p := mk.Ef[Sig := Sig](R);
  (A ~ p :: ps, A -> R ~ ps, p Handled(ps)) -> R ~ ps
let (c, f, h) => mk.Comp (s). c pr(h :: s) finally(_ pr(s) @ f)


val pure.Comp[ps : EfList, A : Ty] : A -> A ~ ps
let => mk.Comp @ const @ pure.PreComp


val _>>=_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, A -> B ~ ps) -> B ~ ps
let (c, f) => mk.Comp (s). bind.PreComp(c pr(s))(_ pr(s) @ f)


val _:>>_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, [] -> B ~ ps) -> B ~ ps
let (x, y) => x >>= (_). y[]


val _IsMonad~\_CompDom\EfList[ps : EfList] : ps CompDom -> (_ ~ ps) IsMonad\_->_
let (s) => isMonad((a, A). pure.Comp(a), (x, f, A, B). x >>= f)


val _Handler\_->_ : (Ty -> Ty, (Ty, EfList) -> Ty, (Ty -> Ty) List) -> Ty
let (Sig, F, Sigs) =>
  (ps : EfList, ps HasSignas(Sigs), R; A : Ty, Sig(A), A -> F(R, ps) ~ ps) ->
  F(R, ps) ~ ps


## XXX This could probably use _PreComp instead of _~_ to avoid
## circular data dependency.
## The user can define it like this, but convert to PreComp
## before storing in _Handled.
val _Finalizer\_->_ : ((Ty, EfList) -> Ty, (Ty -> Ty) List) -> Ty
let (F, Sigs) => (ps : EfList, ps HasSignas(Sigs), X : Ty, X) -> F(X, ps) ~ ps


## XXX This could probably use _PreComp instead of _~_ to avoid
## circular data dependency.
## The user can define it like this, but convert to PreComp
## before storing in _Handled.
val _Scoper\_->_ : (Ty -> Ty, (Ty, EfList) -> Ty, (Ty -> Ty) List) -> Ty
let (Sig, F, Sigs) =>
  (ps : EfList, ps HasSignas(Sigs), R; A : Ty,
    F(A, ps) ~ ps,      ## The handled A ~ p :: ps
    A -> F(R, ps) ~ ps  ## The current continuation obtained from
                        ## contT (f : A -> ps PreComp(F(R, ps))). ...
  ) ->
  F(R, ps) ~ ps


data.. _Handled\_->_ : (Ty -> Ty, (Ty, EfList) -> Ty, (Ty -> Ty) List) -> Ty
let mkHandledSig.Ef[Sig : Ty -> Ty, F : (Ty, EfList) -> Ty, Sigs : (Ty -> Ty) List] : (
  Sig Handler(F, Sigs),
  F Finalizer(Sigs),
  Sig Scoper(F, Sigs)
) -> Sig Handled(F, Sigs)


val _scoper\_Handled\_->_[Sig : Ty -> Ty, F : (Ty, EfList) -> Ty, Sigs : (Ty -> Ty) List] :
  Sig Handled(F, Sigs) -> Sig Scoper(F, Sigs)
let (mkHandledSig.Ef(_, _, s)) => s


val _handle\_Handled\_->_[A : Ty, Sig : Ty -> Ty,
    Sigs : (Ty -> Ty) List, F : (Ty, EfList) -> Ty, ps : EfList] :
  (Sig Handled(F, Sigs), ps HasSignas(Sigs), (p : Sig Ef) -> A ~ p :: ps) ->
  F(A, ps) ~ ps
let (mkHandledSig.Ef(ha, fn, sc), hs, c) =>
  mk.Comp (s). do
  f := (X, x). contT (f). ha(ps, hs, A, X, x, mk.Comp @ const @ f) pr(s);
  hd := mkHandled.Ef[p := p](f, hs, mkHandledSig.Ef(ha, fn, sc), A $ refl);
  c(p) ap(fn(ps, hs, A, _), hd) pr(s)
where
  val p : Sig Ef
  let => mk.Ef(F(A, ps))
end


val _eval\_~_\Ty[R : Ty] : R ~ nil.EfList -> R
let (mk.Comp(c)) => c(nil.CompDom)


data PartialSigna : Ty -> Ty
let failOp[A : Ty] : PartialSigna(A)


val partialHandler[Sigs : (Ty -> Ty) List] : PartialSigna Handler((A, _). ? A, Sigs)
let (_, _, _, _, failOp, k) => pure.Comp(no)


val partialFinalizer[Sigs : (Ty -> Ty) List] : ((A, _). ? A) Finalizer(Sigs)
let (_, _, X, x) => pure.Comp(yes(x))


val partialScoper[Sigs : (Ty -> Ty) List] : PartialSigna Scoper((A, _). ? A, Sigs)
let (ps, _, R, A, c, k) =>
  c >>= (c).
  case c
  of no => pure.Comp(no)
  of yes(x) => k(x)
  end


val partialHandled[Sigs : (Ty -> Ty) List] : PartialSigna Handled((A, _). ? A, Sigs)
let => mkHandledSig.Ef(partialHandler, partialFinalizer, partialScoper)


val runPartialHandler[A : Ty, ps : EfList] :
  ((pa : PartialSigna Ef) -> A ~ pa :: ps) -> (? A) ~ ps
let (c) => partialHandled handle(ps hasSignas, c)


val _lift\_~_\Ty[A : Ty, Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  A ~ ps -> A ~ p :: ps
let (c) => mk.Comp (s). isMonad.PreComp lift(c pr(s tail!))


val _apply\_Ef\_->_[ps : EfList, A : Ty, Sig : Ty -> Ty] :
    (p : Sig Ef, Sig(A), ps Has(p)) -> A ~ ps
let (p, op, here.Has) => mk.Comp (s). s head ap(A, op)
let (p, op, s' there) => p apply(op, s') lift


val testPartialEffect : (Nat, Nat) -> ? Nat
let (x, y) =>
  _eval do
  runPartialHandler (pa).
  get(pa, x) >>= (x).
  get(pa, y) >>= (y).
  pure.Comp(x + y)
where
  val get : (pa : PartialSigna Ef, Nat) -> Nat ~ pa :: nil.EfList
  let (pa, n) => if(n =? 0) then(pa apply(failOp, here.Has)) else(pure.Comp(n))
end


data StateSigna : Ty -> Ty -> Ty
let getOp[A : Ty] : StateSigna(A)(A)
let putOp[A : Ty] : A -> StateSigna(A)(Unit)


val stateHandler[S : Ty, Sigs : (Ty -> Ty) List] :
  StateSigna(S) Handler((A, ps). S -> S & A ~ ps, Sigs)
let (_, _, _, _, getOp, k) => pure.Comp (s). k(s) >>= (k). k(s)
let (_, _, _, _, putOp(x), k) => pure.Comp (_). k(unit) >>= (k). k(x)


val stateFinalizer[S : Ty, Sigs : (Ty -> Ty) List] :
  ((A, ps). S -> S & A ~ ps) Finalizer(Sigs)
let (_, _, X, x) => pure.Comp((s). pure.Comp(s $ x))


val stateScoper[S : Ty, Sigs : (Ty -> Ty) List] :
  StateSigna(S) Scoper((A, ps). S -> S & A ~ ps, Sigs)
let (ps, _, R, A, f, k) =>
  f >>= (f).
  pure.Comp (s).
  f(s) >>= (q).
  k(q 2) >>= (k).
  k(q 1)


val stateHandled[S : Ty, Sigs : (Ty -> Ty) List] :
  StateSigna(S) Handled((A, ps). S -> S & A ~ ps, Sigs)
let => mkHandledSig.Ef(stateHandler, stateFinalizer, stateScoper)


val runStateHandler[A; S : Ty, ps : EfList]
  : S -> ((st : StateSigna(S) Ef) -> A ~ st :: ps) -> S & A ~ ps
let (s) => (c).
  stateHandled handle(ps hasSignas, c) >>= (f). f(s)


val partialStatePlus[ps : EfList,
    st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa), Nat, Nat) -> Nat ~ ps
let (hst, hpa, m, n) =>
  check(m) :>>
  st apply(putOp(m), hst) :>>
  check(n) :>>
  st apply(getOp, hst) >>= (m).
  st apply(putOp(m + n), hst) :>>
  st apply(getOp, hst) >>= (r).
  pure.Comp(r)
where
  val check : Nat -> Unit ~ ps
  let (x) => if(x =? 0) then(pa apply(failOp, hpa)) else(pure.Comp(unit))
end


val partialPlusWithStateEffect : (Nat, Nat) -> ? (Nat & Nat)
let (m, n) =>
  _eval do
  runPartialHandler (pa).
  runStateHandler(0) (st).
  partialStatePlus(here.Has, here.Has there, m, n)


val plusPartialWithStateEffect : (Nat, Nat) -> Nat & ? Nat
let (m, n) =>
  _eval do
  runStateHandler(0) (st).
  runPartialHandler (pa).
  partialStatePlus(here.Has there, here.Has, m, n)


data ChoiceSigna : Ty -> Ty
let decideOp : ChoiceSigna(Bool)


val choiceHandler[Sigs : (Ty -> Ty) List] : ChoiceSigna Handler((A, _). A List, Sigs)
let (_, _, _, _, decideOp, k) =>
  k(true) >>= (x).
  k(false) >>= (y).
  pure.Comp(x :+: y)


val choiceFinalizer[Sigs : (Ty -> Ty) List] : ((A, _). A List) Finalizer(Sigs)
let (_, _, X, x) => pure.Comp(x :: nil)


val choiceScoper[Sigs : (Ty -> Ty) List] : ChoiceSigna Scoper((A, _). A List, Sigs)
let (ps, _, R, A, xs, k) => xs >>= runCont
where
  val runCont : A List -> R List ~ ps
  let (nil) => pure.Comp(nil)
  let (x :: xs) =>
    k(x) >>= (x).
    runCont(xs) >>= (xs).
    pure.Comp(x :+: xs)
end


val choiceHandled[Sigs : (Ty -> Ty) List] : ChoiceSigna Handled((A, _). A List, Sigs)
let => mkHandledSig.Ef(choiceHandler, choiceFinalizer, choiceScoper)


val runChoiceHandler[A : Ty, ps : EfList] :
  ((ch : ChoiceSigna Ef) -> A ~ ch :: ps) -> A List ~ ps
let (c) => choiceHandled handle(ps hasSignas, c)


val testChoice[ps : EfList,
    c1 : ChoiceSigna Ef, c2 : ChoiceSigna Ef] :
  (ps Has(c1), ps Has(c2)) -> Nat ~ ps
let (h1, h2) =>
  c1 apply(decideOp, h1) >>= (b1). do
  x := if(b1) then(10) else(10 + 10);
  c2 apply(decideOp, h2) >>= (b2). do
  y := if(b2) then(0) else(5);
  pure.Comp(x - y)


val testChoice1 : Nat List List
let =>
  _eval do
  runChoiceHandler (c1).
  runChoiceHandler (c2).
  testChoice(here.Has there, here.Has)


val testChoice2 : Nat List List
let =>
  _eval do
  runChoiceHandler (c2).
  runChoiceHandler (c1).
  testChoice(here.Has, here.Has there)


val testChoice3 : Nat List
let =>
  _eval do
  runChoiceHandler (c).
  testChoice(here.Has, here.Has)


data IOSigna : Ty -> Ty
let printlnOp : Str -> IOSigna(Unit)


val ioHandler : IOSigna Handler((A, _). () ->> A, nil)
let (nil.EfList, nilSignas.Ef, _, _, printlnOp(s), k) =>
  pure.Comp (). k(s println) eval()


val ioFinalizer : ((A, _). () ->> A) Finalizer(nil)
let (_, _, A, a) => pure.Comp((). a)


val ioScoper : IOSigna Scoper((A, _). () ->> A, nil)
let (nil.EfList, nilSignas.Ef, R, A, c, k) =>
  pure.Comp (). k(c eval()) eval()


val ioHandled : IOSigna Handled((A, _). () ->> A, nil)
let => mkHandledSig.Ef(ioHandler, ioFinalizer, ioScoper)


val runIOHandler[A : Ty] :
  ((io : IOSigna Ef) -> A ~ io :: nil.EfList) ->> A
let (c) =>
  ioHandled handle(nilSignas.Ef, c) eval()


val decr[ps : EfList, st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa)) -> Unit ~ ps
let (hst, hpa) =>
  st apply(getOp, hst) >>= (x).
  case x
  of 0 => pa apply(failOp, hpa)
  of ++ x => st apply(putOp(x), hst)
  end


val tripleDecr[ps : EfList, st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa)) -> Unit ~ ps
let (hst, hpa) =>
  decr(hst, hpa) :>>
  st apply(getOp, hst) >>= (s0).
  case hpa
  of _ there =>
    e := (
      _eval do
      runPartialHandler (pa).
      runStateHandler(s0) (st).
      decr(here.Has, here.Has there) :>>
      decr(here.Has, here.Has there)
    );
    case e
    of no => pure.Comp(unit)
    of yes(s $ unit) => st apply(putOp(s), hst)
    end
  of here.Has =>
    e := (
      _eval do
      runStateHandler(s0) (st).
      runPartialHandler (pa).
      decr(here.Has there, here.Has) :>>
      decr(here.Has there, here.Has)
    );
    s $ _ := e;
    st apply(putOp(s), hst) >>= (_).
    pure.Comp(unit)
  end


val _scope\_Handled\_->_[A; R : Ty, Sig : Ty -> Ty,
    p : Sig Ef, ps : EfList, F : (Ty, EfList) -> Ty] :
  ((Sigs : (Ty -> Ty) List) -> Sig Handled(F, Sigs),
    ps Has(p),
    (ts : EfList, ts HasSignas(ps Signas)) -> A ~ ts,
    (qs : EfList, F(A, qs)) -> R ~ qs) ->
  R ~ ps
let (hd, hs, k, r) => mk.Comp (ds). handleAll(hs, ds, k, r)
where
  val handleAll[A : Ty, ps : EfList] :
    (ps Has(p), ps CompDom,
      (ts : EfList, ts HasSignas(ps Signas)) -> A ~ ts,
      (qs : EfList, F(A, qs)) -> R ~ qs) -> ps PreComp(R)
  let (here.Has[ps := ps'], ds, k, r) =>
    c := hd(ps' Signas)
         handle(ps' hasSignas, (p). k(p :: ps', ps' hasSignas cons))
         pr(ds tail!);
    isMonad.PreComp lift(c) >>= (c).
    r(ps', c) lift pr(ds)
  let (hs there[q := q, ps := ps'], ds, k, r) =>
    contT do
      dh := ds head;
      R' $ isRet := dh retIsRet;
      isRet rew((X). (R -> ps' PreComp(X)) -> ps' PreComp(X), _) (f). do
      #{
      h := (ts : EfList, th : ts HasSignas(ps' Signas)).
        dh handled handle[ps := ts](
          dh signasIsSignas(th),
          (p'). k(p' :: ts, th cons));
      s := handleAll(hs, ds tail!, undefined, undefined);
      #}
      s := handleAll(hs, ds tail!,
        undefined[A :=
          (ts : EfList, ts HasSignas(ps' Signas)) -> A ~ ts
        ],
        r);
      dh handled scoper(ps', dh hasSignas, R', R, undefined, mk.Comp @ const @ f)
      pr(ds tail!)
end


## So the scoping works by running a handler inside a new scope of effects.
## The new scope is created by lifting all the "front" effects.
## The front effects are responsible for lifting themselves.
## They have a chance to obtain the current "state" first.
## If the front effect is p and the rest is ps, then it executes inside
## p :: ps where it can obtain state, then lift into ps where
## it recursively passes itself (or maybe a handler of itself),
## to obtain a reversed list of the front effects (or handlers of
## the front effects). When we get to the effect q being scoped with
## tail qs, it will lift q :: qs to qs, then run the handler. It will
## then run the (reversed) list of handlers of the front effects.
## Now, in here, we execute the given computation,
## which produces some result F1(F2(F3(X))) ~ qs (after running).
## The first handler of q is responsible for converting the result
## of running F1(F2(F3(X))) ~ qs to F2(F3(X)) ~ q :: qs.
## Then returning from recursion, the previous effect, say p, needs
## to convert F2(F3(X)) ~ q :: qs into F3(X) ~ p :: q :: qs, and so on,
## where the F1, F2, etc. are supposed to be known by each effect,
## but I guess that X can be polymorphic while the effects are converting,
## for example, F2(F3(X)) ~ q :: qs into F3(X) ~ p :: q :: qs.
##
## Something like this is needeed:
#{
  data _Handled\_->_ : (Ty -> Ty) -> Ty
  let mk.Handled[Sig; F : Ty -> Ty, ps : EfList] : (
    Sig Handler(F, ps),
    (A : Ty, p : Sig Ef) -> F(A) ~ ps -> A ~ p :: ps
  ) -> Sig Handled
#}


val tripleDecrStPa : Nat & ? Unit
let =>
  _eval do
  runStateHandler(2) (st).
  runPartialHandler (pa).
  tripleDecr(here.Has there, here.Has)


val tripleDectPaSt : ? (Nat & Unit)
let =>
  _eval do
  runPartialHandler (pa).
  runStateHandler(2) (st).
  tripleDecr(here.Has, here.Has there)


val testIOPartial[ps : EfList, io : IOSigna Ef] : ps Has(io) -> Unit ~ ps
let (hio) =>
  pr := testPartialEffect(2, 0) str(_str);
  io apply(printlnOp(pr), hio) :>> do
  pr := testPartialEffect(0, 2) str(_str);
  io apply(printlnOp(pr), hio) :>> do
  pr := testPartialEffect(2, 2) str(_str);
  io apply(printlnOp(pr), hio)


val main : () ->> Unit
let () =>
  runIOHandler (io). testIOPartial(here.Has);
  partialPlusWithStateEffect(2, 0) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(0, 2) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(2, 2) str((p). p str(_str, (x, _). x str)) println;
  plusPartialWithStateEffect(2, 0) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(0, 2) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(2, 2) str(_str, (x, _). x str(_str)) println;
  ("[" :+: testChoice1 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println;
  ("[" :+: testChoice2 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println;
  ("[" :+: testChoice3 str(_str, ",") :+: "]") println;
  tripleDecrStPa str(_str, (x, _). x str((_). "unit")) println;
  tripleDectPaSt str(_ str(_str, (_, _). "unit")) println
