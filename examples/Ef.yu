import "yu/prelude.yu"


data _IsMonad\_->_ : (Ty -> Ty) -> Ty
let isMonad[M : Ty -> Ty] : (
  (A, A : Ty) -> M(A),
  (M(A), A -> M(B), A : Ty, B : Ty) -> M(B)
) -> M IsMonad


val _pure\_IsMonad\_->_[A : Ty, M : Ty -> Ty] : M IsMonad -> A -> M(A)
let (isMonad(r, _)) => r(_, A)


val _bind\_IsMonad\_->_[A; B : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> (A -> M(B)) -> M(B)
let (isMonad(_, b), a) => (f). b(a, f, A, B)


val idIsMonad : id IsMonad
let => isMonad(_:!_, bind)
where
  val bind : (A, A -> B, A; B : Ty) -> B
  let (x, f, A, B) => f(x)
end


data _ContT\Ty : (Ty, Ty, M : Ty -> Ty) -> Ty
let contT[A; R : Ty, M : Ty -> Ty] :
  ((A -> M(R)) -> M(R)) -> A ContT(R, M)


val _finally\_ContT\Ty[A; R : Ty, M : Ty -> Ty] : (A ContT(R, M), A -> M(R)) -> M(R)
let (contT(c), k) => c(k)


val pure.ContT[A; R : Ty, M : Ty -> Ty] : A -> A ContT(R, M)
let (a) => contT (k). k(a)


val _>>=_\_ContT\Ty[A; B; R : Ty, M : Ty -> Ty]:
  (A ContT(R, M), A -> B ContT(R, M)) -> B ContT(R, M)
let (x, f) => contT (k). x finally (a). f(a) finally(k)


val contTIsMonad[R : Ty, M : Ty -> Ty] : _ ContT\Ty(R, M) IsMonad
let => isMonad((a, A). pure.ContT(a), (x, f, A, B). x >>= f)


val _lift\_IsMonad\_->_[A; R : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> A ContT(R, M)
let (isM, x) => contT do isM bind(x)


data _Ef\_->_ : (Ty -> Ty) -> Ty
let mk.Ef[Sig : Ty -> Ty] : Ty -> Sig Ef


val _Ty\_Ef\_->_[Sig : Ty -> Ty] : Sig Ef -> Ty
let (mk.Ef(R)) => R


data EfList : Ty
let nil.EfList : EfList
let _::_\EfList[Sig : Ty -> Ty] : (Sig Ef, EfList) -> EfList


val _tail!\EfList : EfList -> EfList
let (nil.EfList) => nil.EfList
let (_ :: ps) => ps


data _Has\EfList[Sig : Ty -> Ty] : (EfList, Sig Ef) -> Ty
let here.Has[ps : EfList, Sig : Ty -> Ty, p : Sig Ef] :
  (p :: ps) Has(p)
let _there\_Has\EfList[ps : EfList, Sigp; Sigq : Ty -> Ty, p : Sigp Ef, q : Sigq Ef] :
  ps Has(p) -> (q :: ps) Has(p)


val _PreComp\EfList : EfList -> Ty -> Ty
let (nil.EfList) => id
let (p :: ps) => _ ContT(p Ty, ps PreComp)


val pure.PreComp[ps : EfList, A : Ty] : A -> ps PreComp(A)
let [ps := nil.EfList] => id
let [ps := p :: ps] => pure.ContT


val bind.PreComp[ps : EfList, A; B : Ty] :
  ps PreComp(A) -> (A -> ps PreComp(B)) -> ps PreComp(B)
let [ps := nil.EfList] => (a). (f). f(a)
let [ps := p :: ps] => (a). (f). a >>= f


val isMonad.PreComp[ps : EfList] : ps PreComp IsMonad
let => isMonad((a, A). pure.PreComp(a), (x, f, A, B). bind.PreComp(x)(f))


data _CompDom\EfList : EfList -> Ty
let nil.CompDom : nil.EfList CompDom
let _::_\_CompDom\EfList[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  ((A : Ty, Sig(A)) -> A ContT(p Ty, ps PreComp), ps CompDom) -> (p :: ps) CompDom


data _~_\Ty : (Ty, EfList) -> Ty
let mk.Comp[ps : EfList, A : Ty] : (ps CompDom -> ps PreComp(A)) -> A ~ ps


val _head\_CompDom\EfList[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (p :: ps) CompDom -> (A : Ty, Sig(A)) -> A ContT(p Ty, ps PreComp)
let (h :: _) => h


val _tail!\_CompDom\EfList[ps : EfList] : ps CompDom -> ps tail! CompDom
let (nil.CompDom) => nil.CompDom
let (_ :: ds) => ds


val _pr\_~_\Ty[ps : EfList, A : Ty] : (A ~ ps, ps CompDom) -> ps PreComp(A)
let (mk.Comp(c), s) => c(s)


val _ap\_~_\Ty[ps : EfList, A; R : Ty, Sig : Ty -> Ty] :
  (A ~ mk.Ef[Sig := Sig](R) :: ps, A -> R ~ ps,
    h : (B : Ty, Sig(B)) -> B ContT(R, ps PreComp)) -> R ~ ps
let (c, f, h) => mk.Comp (s). c pr(h :: s) finally(_ pr(s) @ f)


val pure.Comp[ps : EfList, A : Ty] : A -> A ~ ps
let => mk.Comp @ const @ pure.PreComp


val _>>=_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, A -> B ~ ps) -> B ~ ps
let (c, f) => mk.Comp (s). bind.PreComp(c pr(s))(_ pr(s) @ f)


val _:>>_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, [] -> B ~ ps) -> B ~ ps
let (x, y) => x >>= (_). y[]


val _IsMonad~\_CompDom\EfList[ps : EfList] : ps CompDom -> (_ ~ ps) IsMonad\_->_
let (s) => isMonad((a, A). pure.Comp(a), (x, f, A, B). x >>= f)


val _Handler\_->_ : (Ty -> Ty, Ty, EfList) -> Ty
let (Sig, R, ps) => (A : Ty, Sig(A), A -> R ~ ps) -> R ~ ps


val handle[ps : EfList, A; R : Ty, Sig : Ty -> Ty] :
  (Sig Handler(R, ps), A -> R ~ ps, (p : Sig Ef) -> A ~ p :: ps) -> R ~ ps
let (h, k, c) =>
  mk.Comp (s).
  c(mk.Ef(R)) ap(k, (B, x). contT (f). h(B, x, mk.Comp @ const @ f) pr(s)) pr(s)


val _eval\_~_\Ty[R : Ty] : R ~ nil.EfList -> R
let (mk.Comp(c)) => c(nil.CompDom)


data PartialSigna : Ty -> Ty
let failOp[A : Ty] : PartialSigna(A)


val partialHandler[A : Ty, ps : EfList] : PartialSigna Handler(? A, ps)
let (_, failOp, k) => pure.Comp(no)


val runPartialHandler[A : Ty, ps : EfList] :
  ((pa : PartialSigna Ef) -> A ~ pa :: ps) -> (? A) ~ ps
let (c) => handle(partialHandler, pure.Comp @ yes, c)


val _lift\_~_\Ty[A : Ty, Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  A ~ ps -> A ~ p :: ps
let (c) => mk.Comp (s). isMonad.PreComp lift(c pr(s tail!))


val _apply\_Ef\_->_[ps : EfList, A : Ty, Sig : Ty -> Ty] :
    (p : Sig Ef, Sig(A), ps Has(p)) -> A ~ ps
let (p, op, here.Has) => mk.Comp (s). s head(A, op)
let (p, op, s' there) => p apply(op, s') lift


val testPartialEffect : (Nat, Nat) -> ? Nat
let (x, y) =>
  _eval do
  runPartialHandler (pa).
  get(pa, x) >>= (x).
  get(pa, y) >>= (y).
  pure.Comp(x + y)
where
  val get : (pa : PartialSigna Ef, Nat) -> Nat ~ pa :: nil.EfList
  let (pa, n) => if(n =? 0) then(pa apply(failOp, here.Has)) else(pure.Comp(n))
end


data StateSigna : Ty -> Ty -> Ty
let getOp[A : Ty] : StateSigna(A)(A)
let putOp[A : Ty] : A -> StateSigna(A)(Unit)


val stateHandler[A; S : Ty, ps : EfList] : StateSigna(S) Handler(S -> A ~ ps, ps)
let (_, getOp, k) => pure.Comp (s). k(s) >>= (k). k(s)
let (_, putOp(x), k) => pure.Comp (_). k(unit) >>= (k). k(x)


val runStateHandler[A; S : Ty, ps : EfList]
  : S -> ((st : StateSigna(S) Ef) -> A ~ st :: ps) -> S & A ~ ps
let (s) => (c).
  handle(stateHandler, (a). pure.Comp (s). pure.Comp(s $ a), c) >>= (f). f(s)


val partialStatePlus[ps : EfList,
    st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa), Nat, Nat) -> Nat ~ ps
let (hst, hpa, m, n) =>
  check(m) :>>
  st apply(putOp(m), hst) :>>
  check(n) :>>
  st apply(getOp, hst) >>= (m).
  st apply(putOp(m + n), hst) :>>
  st apply(getOp, hst) >>= (r).
  pure.Comp(r)
where
  val check : Nat -> Unit ~ ps
  let (x) => if(x =? 0) then(pa apply(failOp, hpa)) else(pure.Comp(unit))
end


val partialPlusWithStateEffect : (Nat, Nat) -> ? (Nat & Nat)
let (m, n) =>
  _eval do
  runPartialHandler (pa).
  runStateHandler(0) (st).
  partialStatePlus(here.Has, here.Has there, m, n)


val plusPartialWithStateEffect : (Nat, Nat) -> Nat & ? Nat
let (m, n) =>
  _eval do
  runStateHandler(0) (st).
  runPartialHandler (pa).
  partialStatePlus(here.Has there, here.Has, m, n)


data ChoiceSigna : Ty -> Ty
let decideOp : ChoiceSigna(Bool)


val choiceHandler[ps : EfList, A : Ty] : ChoiceSigna Handler(A List, ps)
let (_, decideOp, k) =>
  k(true) >>= (x).
  k(false) >>= (y).
  pure.Comp(x :+: y)


val runChoiceHandler[A : Ty, ps : EfList] :
  ((ch : ChoiceSigna Ef) -> A ~ ch :: ps) -> A List ~ ps
let (c) => handle(choiceHandler, pure.Comp @ (_ :: nil), c)


val testChoice[ps : EfList,
    c1 : ChoiceSigna Ef, c2 : ChoiceSigna Ef] :
  (ps Has(c1), ps Has(c2)) -> Nat ~ ps
let (h1, h2) =>
  c1 apply(decideOp, h1) >>= (b1). do
  x := if(b1) then(10) else(10 + 10);
  c2 apply(decideOp, h2) >>= (b2). do
  y := if(b2) then(0) else(5);
  pure.Comp(x - y)


val testChoice1 : Nat List List
let =>
  _eval do
  runChoiceHandler (c1).
  runChoiceHandler (c2).
  testChoice(here.Has there, here.Has)


val testChoice2 : Nat List List
let =>
  _eval do
  runChoiceHandler (c2).
  runChoiceHandler (c1).
  testChoice(here.Has, here.Has there)


val testChoice3 : Nat List
let =>
  _eval do
  runChoiceHandler (c).
  testChoice(here.Has, here.Has)


data IOSigna : Ty -> Ty
let printOp : Str -> IOSigna(Unit)


val ioHandler[A : Ty] : IOSigna Handler(() ->> A, nil.EfList)
let (_, printOp(s), k) => pure.Comp (). k(s print) eval()


val runIOHandler[A : Ty] :
  ((io : IOSigna Ef) -> A ~ io :: nil.EfList) ->> A
let (c) => handle(ioHandler, pure.Comp @ (a). ((). a) :! (() ->> A), c) eval()


val decr[ps : EfList, st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa)) -> Unit ~ ps
let (hst, hpa) =>
  st apply(getOp, hst) >>= (x).
  case x
  of 0 => pa apply(failOp, hpa)
  of ++ x => st apply(putOp(x), hst)
  end


val tripleDecr[ps : EfList, st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa)) -> Unit ~ ps
let (hst, hpa) =>
  decr(hst, hpa) :>>
  runPartialHandler((pa).
    decr(hst there, here.Has) :>>
    decr(hst there, here.Has)
  ) >>= const(pure.Comp(unit))


val doubleDecrStPa : Nat & ? Unit
let =>
  _eval do
  runStateHandler(2) (st).
  runPartialHandler (pa).
  tripleDecr(here.Has there, here.Has)


val doubleDecrPaSt : ? (Nat & Unit)
let =>
  _eval do
  runPartialHandler (pa).
  runStateHandler(2) (st).
  tripleDecr(here.Has, here.Has there)


val main : () ->> Unit
let () =>
  testPartialEffect(2, 0) str(_str) println;
  testPartialEffect(0, 2) str(_str) println;
  testPartialEffect(2, 2) str(_str) println;
  partialPlusWithStateEffect(2, 0) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(0, 2) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(2, 2) str((p). p str(_str, (x, _). x str)) println;
  plusPartialWithStateEffect(2, 0) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(0, 2) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(2, 2) str(_str, (x, _). x str(_str)) println;
  ("[" :+: testChoice1 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println;
  ("[" :+: testChoice2 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println;
  ("[" :+: testChoice3 str(_str, ",") :+: "]") println;
  doubleDecrStPa str(_str, (x, _). x str((_). "unit")) println;
  doubleDecrPaSt str(_ str(_str, (_, _). "unit")) println
