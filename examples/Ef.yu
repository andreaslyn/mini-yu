import "yu/prelude.yu"


#{
val _HandlerFun\_->_ : (Ty -> Ty, Ty) -> Ty
let (Sig, R) =>
  (Sig(A), A : Ty, as : _Handle\_->_ Vec, A -> R Ef(as)) -> R Ef(as)

val _handle\_Handler\_->_[R : Ty, Sig : Ty -> Ty, as : _Handle\_->_ Vec]
  (Sig Handler(R), (a : Sig Handle) -> A Ef(a :: as)) ->
  A -> R Ef(as)
where
  Sig Handle ≅ R $ do (B : Ty, Sig(B)) -> B Ef(a :: as)
and
  A Ef(nil) ≅ id
  A Ef(a :: as) ≅ A ContT(a 1, _ Ef(as), efIsMonad)

A ~ a :: as

Need an apply operation:
  _ap[A : Ty, Sig : Ty -> Ty] :
    (a : Sig Handle, Sig(A), as Has(a)) -> A Ef(as)
which requires lifting through _ContT\Ty a number of times.
#}


data _IsMonad\_->_ : (Ty -> Ty) -> Ty
let isMonad[M : Ty -> Ty] : (
  (A, A : Ty) -> M(A),
  (M(A), A -> M(B), A : Ty, B : Ty) -> M(B)
) -> M IsMonad


val _pure\_IsMonad\_->_[A : Ty, M : Ty -> Ty] : M IsMonad -> A -> M(A)
let (isMonad(r, _)) => r(_, A)


val _bind\_IsMonad\_->_[A; B : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> (A -> M(B)) -> M(B)
let (isMonad(_, b), a) => (f). b(a, f, A, B)


val idIsMonad : id IsMonad
let => isMonad(_:!_, bind)
where
  val bind : (A, A -> B, A; B : Ty) -> B
  let (x, f, A, B) => f(x)
end


data _ContT\Ty : (Ty, Ty, M : Ty -> Ty, M IsMonad) -> Ty
let contT[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  ((A -> M(R)) -> M(R)) -> A ContT(R, M, isM)


val _ap\_ContT\Ty[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  (A ContT(R, M, isM), A -> M(R)) -> M(R)
let (contT(c), k) => c(k)


val pure.ContT[A; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  A -> A ContT(R, M, isM)
let (a) => contT (k). k(a)


val _>>=_\_ContT\Ty[A; B; R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  (A ContT(R, M, isM), A -> B ContT(R, M, isM)) -> B ContT(R, M, isM)
let (x, f) => contT (k). x ap (a). f(a) ap(k)


val contTIsMonad[R : Ty, M : Ty -> Ty, isM : M IsMonad] :
  _ ContT\Ty(R, M, isM) IsMonad
let => isMonad((a, A). pure.ContT(a), (x, f, A, B). x >>= f)


val _lift\_IsMonad\_->_[A; R : Ty, M : Ty -> Ty] :
  (isM : M IsMonad, M(A)) -> A ContT(R, M, isM)
let (isM, x) => contT do isM bind(x)


data _Ef\_->_ : (Ty -> Ty) -> Ty
let mkEf[R : Ty, Sig; M : Ty -> Ty, isM : M IsMonad] :
  ((A : Ty, Sig(A)) -> A ContT(R, M, isM)) -> Sig Ef


val _Ty\_Ef\_->_[Sig : Ty -> Ty] : Sig Ef -> Ty
let (mkEf[R := R](_)) => R


data _List\_->_[A : Ty] : (A -> Ty, A List) -> Ty
let nil.HeteroList[A : Ty, P : A -> Ty] : P List(nil)
let _::_\_List\_->_[A : Ty, P : A -> Ty, x : A, xs : A List] :
  (P(x), P List(xs)) -> P List(x :: xs)


data EfList : Ty
let nil.EfList : EfList
let _::_\EfList[Sig : Ty -> Ty] : (Sig Ef, EfList) -> EfList


val _Computation\EfList : EfList -> & (M : Ty -> Ty). M IsMonad
let (nil.EfList) => id $ idIsMonad
let (p :: ps) =>
  _ ContT(p Ty, h 1, h 2) $ contTIsMonad
where
  val h : & (M : Ty -> Ty). M IsMonad
  let => ps Computation
end


val pure.Computation[ps : EfList, A : Ty] : A -> ps Computation 1(A)
let => ps Computation 2 pure


val bind.Computation[ps : EfList, A; B : Ty] :
  ps Computation 1(A) -> (A -> ps Computation 1(B)) -> ps Computation 1(B)
let => ps Computation 2 bind(_)


data _~_\Ty : (Ty, EfList) -> Ty
let mkComp[ps : EfList, A : Ty] :
  ps Computation 1(A) -> A ~ ps


val _pr\_~_\Ty[ps : EfList, A : Ty] : A ~ ps -> ps Computation 1(A)
let (mkComp(c)) => c


## TODO : Fix this unification!
val ap.Computation[ps : EfList, A; R : Ty, Sig : Ty -> Ty] :
  (h : (B : Ty, Sig(B)) -> B ContT(R, _ ~ ps, compIsMonad),
    (mkEf[R := R, Sig := Sig, M := _ ~ ps, isM := compIsMonad](h) :: ps) Computation 1(A), A -> ps Computation 1(R)) ->
  ps Computation 1(R)
let (h, c, f) => c ap(f)


val _ap\_~_\Ty[ps : EfList, A; R : Ty, Sig : Ty -> Ty,
    h : (B : Ty, Sig(B)) -> B ContT(R, _ ~ ps, compIsMonad)] :
  (A ~ mkEf[R := R, Sig := Sig, M := _ ~ ps, isM := compIsMonad](h) :: ps,
    A -> R ~ ps) ->
  R ~ ps
let (mkComp(c), f) => mkComp(ap.Computation[R := R, Sig := Sig](h, c, _pr @ f))


val pure.Comp[ps : EfList, A : Ty] : A -> A ~ ps
let => mkComp @ pure.Computation


val _>>=_\_~_\Ty[ps : EfList, A; B : Ty] :
  (A ~ ps, A -> B ~ ps) -> B ~ ps
let (c, f) => mkComp do bind.Computation(c pr)(_pr @ f)


val compIsMonad[ps : EfList] : (_ ~ ps) IsMonad\_->_
let => isMonad((a, A). pure.Comp(a), (x, f, A, B). x >>= f)


val _Handler\_->_ : (Ty -> Ty, Ty, EfList) -> Ty
let (Sig, R, ps) => (A : Ty, Sig(A), A -> R ~ ps) -> R ~ ps


val handle[ps : EfList, A; R : Ty, Sig : Ty -> Ty] :
  (Sig Handler(R, ps), A -> R ~ ps, (p : Sig Ef) -> A ~ p :: ps) -> R ~ ps
let (h, k, c) => c(mkEf[R := R] (B, x). contT (f). h(B, x, f)) ap(k)
