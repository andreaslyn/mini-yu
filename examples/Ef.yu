import "yu/prelude.yu"


data _IsMonad\_->_ : (Ty -> Ty) -> Ty
let isMonad[M : Ty -> Ty] : (
  (A, A : Ty) -> M(A),
  (M(A), A -> M(B), A : Ty, B : Ty) -> M(B)
) -> M IsMonad


val _pure\_IsMonad\_->_[A : Ty, M : Ty -> Ty] : M IsMonad -> A -> M(A)
let (isMonad(r, _)) => r(_, A)


val _bind\_IsMonad\_->_[A; B : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> (A -> M(B)) -> M(B)
let (isMonad(_, b), a) => (f). b(a, f, A, B)


val idIsMonad : id IsMonad
let => isMonad(_:!_, bind)
where
  val bind : (A, A -> B, A; B : Ty) -> B
  let (x, f, A, B) => f(x)
end


data _ContT\Ty : (Ty, Ty, M : Ty -> Ty) -> Ty
let contT[A; R : Ty, M : Ty -> Ty] :
  ((A -> M(R)) -> M(R)) -> A ContT(R, M)


val _ap\_ContT\Ty[A; R : Ty, M : Ty -> Ty] : (A ContT(R, M), A -> M(R)) -> M(R)
let (contT(c), k) => c(k)


val pure.ContT[A; R : Ty, M : Ty -> Ty] : A -> A ContT(R, M)
let (a) => contT (k). k(a)


val _>>=_\_ContT\Ty[A; B; R : Ty, M : Ty -> Ty]:
  (A ContT(R, M), A -> B ContT(R, M)) -> B ContT(R, M)
let (x, f) => contT (k). x ap (a). f(a) ap(k)


val contTIsMonad[R : Ty, M : Ty -> Ty] : _ ContT\Ty(R, M) IsMonad
let => isMonad((a, A). pure.ContT(a), (x, f, A, B). x >>= f)


val _lift\_IsMonad\_->_[A; R : Ty, M : Ty -> Ty] :
  (M IsMonad, M(A)) -> A ContT(R, M)
let (isM, x) => contT do isM bind(x)


data _Ef\_->_ : (Ty -> Ty) -> Ty
let mk.Ef[R : Ty, Sig; M : Ty -> Ty] :
  ((A : Ty, Sig(A)) -> A ContT(R, M)) -> Sig Ef


val _Ty\_Ef\_->_[Sig : Ty -> Ty] : Sig Ef -> Ty
let (mk.Ef[R := R](_)) => R


val _Monad\_Ef\_->_[Sig : Ty -> Ty] : Sig Ef -> Ty -> Ty
let (mk.Ef[M := M](_)) => M


data _List\_->_[A : Ty] : (A -> Ty, A List) -> Ty
let nil.HeteroList[A : Ty, P : A -> Ty] : P List(nil)
let _::_\_List\_->_[A : Ty, P : A -> Ty, x : A, xs : A List] :
  (P(x), P List(xs)) -> P List(x :: xs)


data EfList : Ty
let nil.EfList : EfList
let _::_\EfList[Sig : Ty -> Ty] : (Sig Ef, EfList) -> EfList


val _tail\EfList : EfList -> EfList
let (nil.EfList) => nil.EfList
let (_ :: ps) => ps


data _Has\EfList[Sig : Ty -> Ty] : (EfList, Sig Ef) -> Ty
let here.Has[ps : EfList, Sig : Ty -> Ty, p : Sig Ef] :
  (p :: ps) Has(p)
let _there\_Has\EfList[ps : EfList, Sigp; Sigq : Ty -> Ty, p : Sigp Ef, q : Sigq Ef] :
  ps Has(p) -> (q :: ps) Has(p)


val _PreComp\EfList : EfList -> Ty -> Ty
let (nil.EfList) => id
let (p :: ps) => _ ContT(p Ty, ps PreComp)


val pure.PreComp[ps : EfList, A : Ty] : A -> ps PreComp(A)
let [ps := nil.EfList] => id
let [ps := p :: ps] => pure.ContT


val bind.PreComp[ps : EfList, A; B : Ty] :
  ps PreComp(A) -> (A -> ps PreComp(B)) -> ps PreComp(B)
let [ps := nil.EfList] => (a). (f). f(a)
let [ps := p :: ps] => (a). (f). a >>= f


val isMonad.PreComp[ps : EfList] : ps PreComp IsMonad
let => isMonad((a, A). pure.PreComp(a), (x, f, A, B). bind.PreComp(x)(f))


data _IsEfList\EfList : EfList -> Ty
let nil.IsEfList : nil.EfList IsEfList
let _cons\_IsEfList\EfList[Sig : Ty -> Ty, ps : EfList] :
  (ps IsEfList, p : Sig Ef, p Monad = ps PreComp) -> (p :: ps) IsEfList


val _Monad=\_IsEfList\EfList[Sig : Ty -> Ty, p : Sig Ef, ps : EfList] :
  (p :: ps) IsEfList -> p Monad = ps PreComp
let (_ cons(_, e))=> e


data _~_\Ty : (Ty, EfList) -> Ty
let mk.Comp[ps : EfList, A : Ty] : (ps IsEfList -> ps PreComp(A)) -> A ~ ps


val _tail\_IsEfList\EfList[ps : EfList] : ps IsEfList -> ps tail IsEfList
let (nil.IsEfList) => nil.IsEfList
let (ss cons(_, _)) => ss


val _pr\_~_\Ty[ps : EfList, A : Ty] : (A ~ ps, ps IsEfList) -> ps PreComp(A)
let (mk.Comp(c), s) => c(s)


val _ap\_~_\Ty[ps : EfList, A; R : Ty, Sig : Ty -> Ty,
    h : (B : Ty, Sig(B)) -> B ContT(R, ps PreComp)] :
  (A ~ mk.Ef(h) :: ps, A -> R ~ ps) -> R ~ ps
let (c, f) => mk.Comp((s). c pr(s cons(mk.Ef(h), refl)) ap(_ pr(s) @ f))


val pure.Comp[ps : EfList, A : Ty] : A -> A ~ ps
let => mk.Comp @ const @ pure.PreComp


val _>>=_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, A -> B ~ ps) -> B ~ ps
let (c, f) => mk.Comp (s). bind.PreComp(c pr(s))(_ pr(s) @ f)


val _:>>_\_~_\Ty[ps : EfList, A; B : Ty] : (A ~ ps, [] -> B ~ ps) -> B ~ ps
let (x, y) => x >>= (_). y[]


val _IsMonad~\_IsEfList\EfList[ps : EfList] : ps IsEfList -> (_ ~ ps) IsMonad\_->_
let (s) => isMonad((a, A). pure.Comp(a), (x, f, A, B). x >>= f)


val _Handler\_->_ : (Ty -> Ty, Ty, EfList) -> Ty
let (Sig, R, ps) => (A : Ty, Sig(A), A -> R ~ ps) -> R ~ ps


val handle[ps : EfList, A; R : Ty, Sig : Ty -> Ty] :
  (Sig Handler(R, ps), A -> R ~ ps, (p : Sig Ef) -> A ~ p :: ps) -> R ~ ps
let (h, k, c) =>
  mk.Comp (s).
  c(mk.Ef (B, x). contT (f). h(B, x, mk.Comp @ const @ f) pr(s)) ap(k) pr(s)


val _eval\_~_\Ty[R : Ty] : R ~ nil.EfList -> R
let (mk.Comp(c)) => c(nil.IsEfList)


data PartialSigna : Ty -> Ty
let failOp[A : Ty] : PartialSigna(A)


val partialHandler[A : Ty, ps : EfList] : PartialSigna Handler(? A, ps)
let (_, failOp, k) => pure.Comp(no)


val runPartialHandler[A : Ty, ps : EfList] :
  ((pa : PartialSigna Ef) -> A ~ pa :: ps) -> (? A) ~ ps
let (c) => handle(partialHandler, pure.Comp @ yes, c)


val _ap\_Ef\_->_[Sig : Ty -> Ty, A : Ty] :
  (p : Sig Ef, Sig(A)) -> A ContT(p Ty, p Monad)
let (mk.Ef(c), x) => c(A, x)


val _lift\_Ef\_->_[ps : EfList, A : Ty, Sig : Ty -> Ty] :
    (p : Sig Ef, Sig(A), ps Has(p)) -> A ~ ps
let (p, op, here.Has) =>
  mk.Comp (s). s Monad= resp(A ContT(p Ty, _) ,p ap(op))
let (p, op, s' there) =>
  mk.Comp (s). isMonad.PreComp lift(p lift(op, s') pr(s tail))


val testPartialEffect : (Nat, Nat) -> ? Nat
let (x, y) =>
  _eval do
  runPartialHandler (pa).
  get(pa, x) >>= (x).
  get(pa, y) >>= (y).
  pure.Comp(x + y)
where
  val get : (pa : PartialSigna Ef, Nat) -> Nat ~ pa :: nil.EfList
  let (pa, n) => if(n =? 0) then(pa lift(failOp, here.Has)) else(pure.Comp(n))
end


data StateSigna : Ty -> Ty -> Ty
let getOp[A : Ty] : StateSigna(A)(A)
let putOp[A : Ty] : A -> StateSigna(A)(Unit)


val stateHandler[A; S : Ty, ps : EfList] : StateSigna(S) Handler(S -> A ~ ps, ps)
let (_, getOp, k) => pure.Comp (s). k(s) >>= (k). k(s)
let (_, putOp(x), k) => pure.Comp (_). k(unit) >>= (k). k(x)


val runStateHandler[A; S : Ty, ps : EfList]
  : S -> ((st : StateSigna(S) Ef) -> A ~ st :: ps) -> S & A ~ ps
let (s) => (c).
  handle(stateHandler, (a). pure.Comp (s). pure.Comp(s $ a), c) >>= (f). f(s)


val partialStatePlus[ps : EfList,
    st : StateSigna(Nat) Ef, pa : PartialSigna Ef] :
  (ps Has(st), ps Has(pa), Nat, Nat) -> Nat ~ ps
let (hst, hpa, m, n) =>
  check(m) :>>
  st lift(putOp(m), hst) :>>
  check(n) :>>
  st lift(getOp, hst) >>= (m).
  st lift(putOp(m + n), hst) :>>
  st lift(getOp, hst) >>= (r).
  pure.Comp(r)
where
  val check : Nat -> Unit ~ ps
  let (x) => if(x =? 0) then(pa lift(failOp, hpa)) else(pure.Comp(unit))
end


val partialPlusWithStateEffect : (Nat, Nat) -> ? (Nat & Nat)
let (m, n) =>
  _eval do
  runPartialHandler (pa).
  runStateHandler(0) (st).
  partialStatePlus(here.Has, here.Has there, m, n)


val plusPartialWithStateEffect : (Nat, Nat) -> Nat & ? Nat
let (m, n) =>
  _eval do
  runStateHandler(0) (st).
  runPartialHandler (pa).
  partialStatePlus(here.Has there, here.Has, m, n)


data ChoiceSigna : Ty -> Ty
let decideOp : ChoiceSigna(Bool)


val choiceHandler[ps : EfList, A : Ty] : ChoiceSigna Handler(A List, ps)
let (_, decideOp, k) =>
  k(true) >>= (x).
  k(false) >>= (y).
  pure.Comp(x :+: y)


val runChoiceHandler[A : Ty, ps : EfList] :
  ((ch : ChoiceSigna Ef) -> A ~ ch :: ps) -> A List ~ ps
let (c) => handle(choiceHandler, pure.Comp @ (_ :: nil), c)


val testChoice[ps : EfList,
    c1 : ChoiceSigna Ef, c2 : ChoiceSigna Ef] :
  (ps Has(c1), ps Has(c2)) -> Nat ~ ps
let (h1, h2) =>
  c1 lift(decideOp, h1) >>= (b1). do
  x := if(b1) then(10) else(10 + 10);
  c2 lift(decideOp, h2) >>= (b2). do
  y := if(b2) then(0) else(5);
  pure.Comp(x - y)


val testChoice1 : Nat List List
let =>
  _eval do
  runChoiceHandler (c1).
  runChoiceHandler (c2).
  testChoice(here.Has there, here.Has)


val testChoice2 : Nat List List
let =>
  _eval do
  runChoiceHandler (c1).
  runChoiceHandler (c2).
  testChoice(here.Has, here.Has there)


val main : () ->> Unit
let () =>
  testPartialEffect(2, 0) str(_str) println;
  testPartialEffect(0, 2) str(_str) println;
  testPartialEffect(2, 2) str(_str) println;
  partialPlusWithStateEffect(2, 0) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(0, 2) str((p). p str(_str, (x, _). x str)) println;
  partialPlusWithStateEffect(2, 2) str((p). p str(_str, (x, _). x str)) println;
  plusPartialWithStateEffect(2, 0) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(0, 2) str(_str, (x, _). x str(_str)) println;
  plusPartialWithStateEffect(2, 2) str(_str, (x, _). x str(_str)) println;
  ("[" :+: testChoice1 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println;
  ("[" :+: testChoice2 str((xs). "[" :+: xs str(_str, ",") :+: "]", ",") :+: "]") println
