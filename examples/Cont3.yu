import "yu/prelude.yu"


data _Cont\Ty : (Ty, M : Ty -> Ty) -> Ty
let cont[A : Ty, M : Ty -> Ty] :
  ((R : Ty, A -> M(R)) -> M(R)) -> A Cont(M)


val _ap\_Cont\Ty[A; B : Ty, M : Ty -> Ty] : (A Cont(M), A -> M(B)) -> M(B)
let (cont(c), k) => c(B, k)


val _run\_Cont\Ty[A; B : Ty, M : Ty -> Ty] : (A Cont(M), A -> M(B)) -> M(B)
let (c, r) => c ap(r)


val pure.Cont[A : Ty, M : Ty -> Ty] : A -> A Cont(M)
let (a) => cont (R, k). k(a)


val _>>=_\_Cont\Ty[A; B : Ty, M : Ty -> Ty] : (A Cont(M), A -> B Cont(M)) -> B Cont(M)
let (x, f) => cont (R, k). x ap (a). f(a) ap(k)


val example6 : Nat -> Bool
let (x) =>
  _ run\_Cont\Ty[B := Bool](id) do
  timesThree(x) >>= (y). do
  greaterThanTen(y) >>= (z). do
  pure.Cont(z)
where
  val timesThree[R : Ty] : Nat -> Nat Cont(const(R))
  let (x) => cont (R, k). k(3 * x)

  val greaterThanTen[R : Ty] : Nat -> Bool Cont(const(R))
  let (y) => cont (R, k). k (10 <? y)
end


val _>=>_\_Cont\Ty[A; B; C : Ty, M : Ty -> Ty] :
  (A -> B Cont(M), B -> C Cont(M)) -> A -> C Cont(M)
let (f, g) => (a). f(a) >>= g


data _Partial\Ty : Ty -> Ty
let partial[A : Ty] : A Cont(? _) -> A Partial


val _cont\_Partial\Ty[A : Ty] : A Partial -> A Cont(? _)
let (partial(x)) => x


val none.Partial[A : Ty] : A Partial
let => partial do cont (_, _). no


val pure.Partial[A : Ty] : A -> A Partial
let (a) => partial do pure.Cont(a)


val _>>=_\_Partial\Ty[A; B : Ty] : (A Partial, A -> B Partial) -> B Partial
let (x, f) => partial do x cont >>= (a). f(a) cont


val _eval\_Partial\Ty[A : Ty] : A Partial -> ? A
let (p) => p cont ap(yes)


val testPartial : (Nat, Nat) -> ? Nat
let (x, y) =>
  _eval do
  get(x) >>= (x).
  get(y) >>= (y).
  pure.Partial(x + y)
where
  val get : Nat -> Nat Partial
  let (n) => if(n =? 0) then(none.Partial) else(pure.Partial(n))
end


val backtrackBool.Partial : Bool Partial
let =>
  partial do cont (R, k).
  case k(true)
  of no => k(false)
  of yes(x) => yes(x)
  end


data _State\Ty : (Ty, Ty) -> Ty
let state[A; S : Ty] : A Cont((R). S -> R) -> A State(S)


val _cont\_State\Ty[A; S : Ty] : A State(S) -> A Cont((R). S -> R)
let (state(x)) => x


val pure.State[A; S : Ty] : A -> A State(S)
let (a) => state do cont (R, k). k(a)


val _>>=_\_State\Ty[A; B; S : Ty] : (A State(S), A -> B State(S)) -> B State(S)
let (x, f) => state do x cont >>= (a). f(a) cont


val get.State[S : Ty] : S State(S)
let => state do cont (R, k). (s). k(s)(s)


val put.State[S : Ty] : S -> Unit State(S)
let (s) => state do cont (R, k). (_). k(unit)(s)


val _eval\_State\Ty[A; S : Ty] : (A State(S), S) -> A & S
let (m, s) => m cont ap((a). a $ _)(s)


val plusWithState : (Nat, Nat) -> Nat
let (m, n) =>
  _2 do _ eval\_State\Ty(m) do
  get.State >>= put.State @ (n + _)


val _Handler\_->_ : (M : Ty -> Ty, sig : Ty -> Ty) -> Ty
let (M, sig) => (sig(A), A -> M(B), A; B : Ty) -> M(B)


data StateSigna : Ty -> Ty -> Ty
let getOp[A : Ty] : StateSigna(A)(A)
let putOp[A : Ty] : A -> StateSigna(A)(Unit)


val stateHandler[S : Ty] : ((A : Ty). S -> S & A) Handler(StateSigna(S))
let (getOp, k, A, B) => (s). k(s)(s)
let (putOp(x), k, A, B) => (_). k(unit)(x)


val handle[A : Ty, M; Sig : Ty -> Ty] :
  ((Sig(A) -> A Cont(M)) -> A Cont(M), M Handler(Sig)) -> A Cont(M)
let (c, h) =>
  cont (R, k : A -> M(R)). c((a : Sig(A)). cont (B, f : A -> M(B)). h(a, f, A, B)) ap(k)


val testHandle : Nat Cont((R). Nat -> Nat & R)
let =>
  handle(_, stateHandler) (st).
    st(putOp(0)) >>= (_).
    pure.Cont(0)
    ##st(getOp) >>= (n).


val main : () ->> Unit
let () =>
  example6(3) println;
  example6(4) println;
  testPartial(2, 0) str(_str) println;
  testPartial(0, 2) str(_str) println;
  testPartial(2, 2) str(_str) println;
  plusWithState(4, 5) println
